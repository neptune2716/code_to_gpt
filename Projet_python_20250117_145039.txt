├── .gitignore
├── AiUtils
│   └── aStar.py
├── Controller
│   ├── camera.py
│   ├── drawing.py
│   ├── event_handler.py
│   ├── game_loop.py
│   ├── gui.py
│   ├── init_assets.py
│   ├── init_map.py
│   ├── init_player.py
│   ├── terminal_display.py
│   ├── terminal_display_debug.py
│   ├── update.py
│   └── utils.py
├── Entity
│   ├── Building
│   │   ├── ArcheryRange.py
│   │   ├── Barracks.py
│   │   ├── Building.py
│   │   ├── Camp.py
│   │   ├── Farm.py
│   │   ├── House.py
│   │   ├── Keep.py
│   │   ├── Stable.py
│   │   ├── TownCentre.py
│   │   └── __init__.py
│   ├── Entity.py
│   ├── Resource
│   │   ├── Gold.py
│   │   ├── Resource.py
│   │   └── Tree.py
│   └── Unit
│       ├── Archer.py
│       ├── Horseman.py
│       ├── Swordsman.py
│       ├── Unit.py
│       ├── Villager.py
│       └── __init__.py
├── Models
│   ├── Map.py
│   ├── Resources.py
│   ├── Team.py
│   └── html.py
├── Settings
│   ├── entity_mapping.py
│   └── setup.py
├── a.out
├── assets
│   ├── UI
│   │   ├── Panels
│   │   │   ├── minimapPan
│   │   │   │   └── map-panel.webp
│   │   │   └── resourcesPan
│   │   │       └── resource-panel.webp
│   │   ├── Pointer
│   │   │   └── attack48x48 (Copy).webp
│   │   └── Resources
│   │       ├── food
│   │       │   └── resource_food.webp
│   │       ├── gold
│   │       │   └── resource_gold.webp
│   │       └── wood
│   │           └── resource_wood.webp
│   ├── buildings
│   │   ├── archeryrange
│   │   │   ├── death
│   │   │   │   └── archery_destruction.webp
│   │   │   └── idle
│   │   │       └── archery_idle.webp
│   │   ├── barracks
│   │   │   ├── death
│   │   │   │   └── barracks_destruction.webp
│   │   │   └── idle
│   │   │       └── barracks_idle.webp
│   │   ├── camp
│   │   │   ├── death
│   │   │   │   └── spritesheet_10x10.webp
│   │   │   └── idle
│   │   │       └── camp_idle.webp
│   │   ├── farm
│   │   │   ├── death
│   │   │   │   └── farm.webp
│   │   │   └── idle
│   │   │       └── farm.webp
│   │   ├── house
│   │   │   ├── death
│   │   │   │   └── house_destruction.webp
│   │   │   └── idle
│   │   │       └── house_idle.webp
│   │   ├── keep
│   │   │   ├── death
│   │   │   │   └── spritesheet_10x10.webp
│   │   │   └── idle
│   │   │       └── image_1x1_0.webp
│   │   ├── stable
│   │   │   ├── death
│   │   │   │   └── stable_destruction.webp
│   │   │   └── idle
│   │   │       └── stable_idle.webp
│   │   └── towncenter
│   │       ├── death
│   │       │   └── towncenter_destruction.webp
│   │       └── idle
│   │           └── towncenter_idle.webp
│   ├── launcher
│   │   └── loading_slash_sml.webp
│   ├── resources
│   │   ├── gold
│   │   │   ├── 1_image_1x1.webp
│   │   │   ├── 2_image_1x1.webp
│   │   │   ├── 3_image_1x1.webp
│   │   │   ├── 4_image_1x1.webp
│   │   │   ├── 5_image_1x1.webp
│   │   │   └── 6_image_1x1.webp
│   │   ├── grass
│   │   │   └── grass1.webp
│   │   └── tree
│   │       ├── Tree.webp
│   │       ├── image_1x1_09.webp
│   │       ├── image_1x1_15.webp
│   │       └── image_1x1_21.webp
│   └── units
│       ├── archer
│       │   ├── attack
│       │   │   └── archer_attack.webp
│       │   ├── death
│       │   │   └── archer_death.webp
│       │   ├── decay
│       │   │   └── archer_decay.webp
│       │   ├── idle
│       │   │   └── archer_idle.webp
│       │   └── walk
│       │       └── archer_walk.webp
│       ├── horseman
│       │   ├── attack
│       │   │   └── hosreman_attack.webp
│       │   ├── death
│       │   │   └── hosreman_death.webp
│       │   ├── decay
│       │   │   └── hosreman_decay.webp
│       │   ├── idle
│       │   │   └── hosreman_idle.webp
│       │   └── walk
│       │       └── hosreman_walk.webp
│       ├── swordsman
│       │   ├── attack
│       │   │   └── swordsman_attack.webp
│       │   ├── death
│       │   │   └── swordsman_death.webp
│       │   ├── decay
│       │   │   └── swordsman_decay.webp
│       │   ├── idle
│       │   │   └── swordsman_idle.webp
│       │   └── walk
│       │       └── swordsman_walk.webp
│       └── villager
│           ├── attack
│           │   └── villager_attack.webp
│           ├── death
│           │   └── villager_death.webp
│           ├── decay
│           │   └── villager_decay.webp
│           ├── idle
│           │   └── villager_idle.webp
│           ├── task
│           │   └── villager_task.webp
│           └── walk
│               └── villager_walk.webp
├── main.py
└── saves
    ├── save_20250113_000208.pkl
    ├── save_20250113_000218.pkl
    ├── save_20250113_000219.pkl
    └── save_20250113_000240.pkl

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\main.py
import pygame
import os
import sys
import threading
import time
import platform
try:
    import msvcrt
except ImportError:
    msvcrt = None

from select import select

from Controller.init_map import init_pygame, game_loop
from Models.Map import GameMap
from Controller.init_player import init_players
from Controller.init_assets import load_sprites
from Settings.setup import SAVE_DIRECTORY
from Controller.gui import run_gui_menu, user_choices, VALID_GRID_SIZES, VALID_BOTS_COUNT, VALID_LEVELS

# Import du curses terminal display
from Controller.terminal_display import start_terminal_interface


def get_input_non_blocking():
    if platform.system() == "Windows" and msvcrt:
        if msvcrt.kbhit():
            return msvcrt.getwche()
        return None
    else:
        rlist, _, _ = select([sys.stdin], [], [], 0)
        if rlist:
            return sys.stdin.readline()
        return None


def ask_terminal_inputs_non_blocking():
    """
    Menu Terminal non-bloquant.
    [1] GUI only / [2] Terminal only / [3] Both (défaut=3)
    puis [1] nouvelle partie / [2] load, etc.

    => On stocke le résultat dans user_choices et on met user_choices["validated"] = True à la fin.
    """
    step = 0
    saves = []

    while True:
        if user_choices["validated"]:
            return  # On arrête dès que c'est validé

        if step == 0:
            print("\n--- Choisir le mode d'affichage ---")
            print("[1] GUI only / [2] Terminal only / [3] Both ? (défaut=3)")
            step = 1

        elif step == 2:
            print("\n--- Menu Terminal ---")
            print("[1] Nouvelle partie / [2] Charger une sauvegarde ?")
            step = 3

        elif step == 4:
            print("\n--- Paramètres de la nouvelle partie : ---")
            print("Tailles possibles :", VALID_GRID_SIZES)
            print(f"Taille (défaut={user_choices['grid_size']}) : ")
            step = 5

        elif step == 6:
            print(f"Nb bots possibles : 1..55 (défaut={user_choices['num_bots']})")
            print("Nb bots : ")
            step = 7

        elif step == 8:
            print("Niveaux possibles :", VALID_LEVELS)
            print(f"Niveau bots (défaut={user_choices['bot_level']}) : ")
            step = 9

        elif step == 10:
            print("Or au centre ? (oui/non, défaut=non) : ")
            step = 11

        # Lecture non bloquante
        line_in = get_input_non_blocking()
        if line_in is not None:
            line = line_in.strip()

            if step == 1:
                if line == "":
                    user_choices["index_terminal_display"] = 2  # Both
                    print("Aucun choix => Both.")
                elif line in ['1', '2', '3']:
                    val = int(line)
                    if val == 1:
                        user_choices["index_terminal_display"] = 0
                        print("Mode choisi : GUI only.")
                    elif val == 2:
                        user_choices["index_terminal_display"] = 1
                        print("Mode choisi : Terminal only.")
                    else:
                        user_choices["index_terminal_display"] = 2
                        print("Mode choisi : Both (GUI+Terminal).")
                else:
                    user_choices["index_terminal_display"] = 2
                    print("Choix invalide => Both.")
                step = 2

            elif step == 3:
                if line == '2':
                    user_choices["load_game"] = True
                    if os.path.isdir(SAVE_DIRECTORY):
                        saves = [f for f in os.listdir(SAVE_DIRECTORY) if f.endswith('.pkl')]
                        if saves:
                            print("Saves disponibles :")
                            for idx, sf in enumerate(saves):
                                print(f"{idx+1} - {sf}")
                            print("Sélection de la sauvegarde : ")
                            step = 12
                        else:
                            print("Aucune sauvegarde => nouvelle partie.")
                            user_choices["load_game"] = False
                            step = 4
                    else:
                        print("Pas de répertoire => nouvelle partie.")
                        user_choices["load_game"] = False
                        step = 4
                else:
                    user_choices["load_game"] = False
                    step = 4

            elif step == 12:
                if line == "":
                    print("Pas de saisie => nouvelle partie.")
                    user_choices["load_game"] = False
                    step = 4
                else:
                    try:
                        sel_idx = int(line) - 1
                        if 0 <= sel_idx < len(saves):
                            user_choices["chosen_save"] = os.path.join(SAVE_DIRECTORY, saves[sel_idx])
                            user_choices["validated"] = True
                            return
                        else:
                            print("Index invalide => nouvelle partie.")
                            user_choices["load_game"] = False
                            step = 4
                    except:
                        print("Choix invalide => nouvelle partie.")
                        user_choices["load_game"] = False
                        step = 4

            elif step == 5:
                if line == "":
                    print(f"Pas de saisie => taille par défaut {user_choices['grid_size']}")
                    step = 6
                else:
                    if line.isdigit():
                        val = int(line)
                        if val in VALID_GRID_SIZES:
                            user_choices["grid_size"] = val
                            print(f"Taille : {val}")
                    step = 6

            elif step == 7:
                if line == "":
                    print(f"Pas de saisie => nb bots par défaut {user_choices['num_bots']}")
                    step = 8
                else:
                    if line.isdigit():
                        val = int(line)
                        if 1 <= val <= 55:
                            user_choices["num_bots"] = val
                            print(f"Nb bots : {val}")
                    step = 8

            elif step == 9:
                if line == "":
                    print(f"Pas de saisie => niveau bots par défaut {user_choices['bot_level']}")
                    step = 10
                else:
                    if line in VALID_LEVELS:
                        user_choices["bot_level"] = line
                        print(f"Niveau bots : {line}")
                    step = 10

            elif step == 11:
                if line == "":
                    step = 13
                else:
                    if line.lower() == "oui":
                        user_choices["gold_at_center"] = True
                    step = 13

            if step == 13:
                user_choices["validated"] = True
                return

        time.sleep(0.01)


def main():
    """
    1) On lance init_pygame + load_sprites => tous les prints de chargement
       s'effectuent maintenant, avant le menu => pas de confusion dans curses.

    2) On lance un 'menu terminal' non-bloquant pour que l'utilisateur choisisse
       [GUI only / Terminal only / Both], etc.

    3) Selon le choix, on se comporte différemment (lancement curses, etc.).
    """
    while True:
        # 1) Initialisation pygame + chargement des sprites
        screen, sw, sh = init_pygame()

        from Controller.init_assets import load_sprites, ASSETS_LOADED
        if not ASSETS_LOADED:
            load_sprites(screen, sw, sh)

        # 2) On lance le menu terminal en thread (non-bloquant)
        t_menu = threading.Thread(target=ask_terminal_inputs_non_blocking)
        t_menu.start()

        # 3) On lance la GUI menu => si l'utilisateur veut "Terminal only",
        #    on aura quand même un fenêtrage, mais on va l'arrêter aussitôt
        #    qu'il aura validé le choix. On peut laisser le code existant:
        from Controller.gui import run_gui_menu
        run_gui_menu(screen, sw, sh)

        # on attend la fin du thread menu
        if t_menu.is_alive():
            t_menu.join()

        # => user_choices est fixé
        mode_index = user_choices["index_terminal_display"]
        # si c'est Terminal only => on ne veut plus de GUI => on clos la fenêtre
        if mode_index == 1:
            # Quitter pygame
            pygame.display.quit()
            # On remet screen=None
            screen = None

        # 4) Lecture des paramètres finaux
        load_game    = user_choices["load_game"]
        chosen_save  = user_choices["chosen_save"]
        grid_size    = user_choices["grid_size"]
        nb_bots      = user_choices["num_bots"]
        bot_level    = user_choices["bot_level"]
        gold_c       = user_choices["gold_at_center"]

        # 5) Création ou chargement de la map
        if load_game and chosen_save:
            game_map = GameMap(0, False, [], generate=False)
            game_map.load_map(chosen_save)
            players = game_map.players
        else:
            players = init_players(nb_bots, bot_level)
            game_map = GameMap(grid_size, gold_c, players)

        # 6) Si mode Terminal only ou Both => lancer curses
        if mode_index in [1, 2]:
            t_curses = threading.Thread(target=start_terminal_interface, args=(game_map,), daemon=True)
            t_curses.start()

        # 7) Lancer la boucle de jeu => s'il n'y a pas de screen => pas d'affichage Pygame
        from Controller.game_loop import game_loop
        game_loop(screen, game_map, sw, sh, players)

        menu_result = user_choices.get("menu_result")
        if menu_result == "main_menu":
            from Controller.terminal_display import stop_curses
            stop_curses()
            pygame.quit()
            user_choices.clear()
            user_choices["menu_result"] = None
            user_choices.update({
                "index_terminal_display": 2,
                "load_game": False,
                "chosen_save": "",
                "grid_size": 120,
                "num_bots": 2,
                "bot_level": "lean",
                "gold_at_center": False,
                "validated": False
            })
            continue
        elif menu_result == "quit":
            break

        # Check if user wants to return to menu
        if game_map.game_state.get('return_to_menu'):
            from Controller.terminal_display import stop_curses
            stop_curses()
            # If curses is running, stop it (stub or custom function)
            # stop_curses()  # Example if you have a dedicated stop function

            # Fully close the old window
            pygame.quit()

            # Reset user choices
            user_choices.clear()
            user_choices.update({
                "index_terminal_display": 2,
                "load_game": False,
                "chosen_save": "",
                "grid_size": 120,
                "num_bots": 2,
                "bot_level": "lean",
                "gold_at_center": False,
                "validated": False
            })

            # Restart from scratch
            continue
        else:
            break

    # ...existing code...

if __name__ == "__main__":
    main()


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\AiUtils\aStar.py
import heapq
import math
from Controller.utils import get_snapped_angle, get_angle

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def get_neighbors(game_map, position):
    directions = [
        (1, 0), (0, 1), (-1, 0), (0, -1),
        (1, 1), (1, -1), (-1, 1), (-1, -1)
    ]
    neighbors = []
    for dx, dy in directions:
        neighbor = (position[0] + dx, position[1] + dy)
        if game_map.walkable_position(neighbor):
            neighbors.append(neighbor)
    return neighbors

def find_nearest_walkable_tile(rounded_goal, game_map):
    open_set = [(0, rounded_goal)]
    visited = set()

    while open_set:
        _, current = heapq.heappop(open_set)

        if game_map.walkable_position(current):
            return current

        visited.add(current)
        for neighbor in get_neighbors(game_map, current):
            if neighbor not in visited:
                distance = heuristic(neighbor, rounded_goal)
                heapq.heappush(open_set, (distance, neighbor))

    return None

def walkable_goal(start, rounded_goal, game_map):
    entities = game_map.grid.get(rounded_goal, None)
    entity = list(entities)[0] if entities else None
    float_offset = None
    if entity:
        angle = get_angle((entity.x, entity.y), start)
        offset_x = ((entity.size - 1) / 2) * math.cos(math.radians(angle))
        offset_y = ((entity.size - 1) / 2) * math.sin(math.radians(angle))
        float_goal = (entity.x + offset_x, entity.y + offset_y)
        float_offset = float_goal
        rg = (round(float_goal[0]), round(float_goal[1]))
        if game_map.walkable_position(rg):
            return rg, float_offset
        tile = find_nearest_walkable_tile(rg, game_map)
        return tile, float_offset
    return rounded_goal, None

def a_star(start, float_goal, game_map):
    rounded_goal = (round(float_goal[0]), round(float_goal[1]))
    if not game_map.walkable_position(rounded_goal):
        rounded_goal, float_building_goal = walkable_goal(start, rounded_goal, game_map)
    else:
        float_building_goal = None

    if not rounded_goal or not game_map.walkable_position(rounded_goal):
        return []

    open_set = []
    rs = (round(start[0]), round(start[1]))
    heapq.heappush(open_set, (0, rs))
    came_from = {}
    g_score = {rs: 0}
    f_score = {rs: heuristic(rs, rounded_goal)}

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == rounded_goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.reverse()
            if float_building_goal and game_map.walkable_position((round(float_building_goal[0]), round(float_building_goal[1]))):
                path.append(float_building_goal)
            elif game_map.walkable_position(float_goal):
                path.append(float_goal)
            return path

        for neighbor in get_neighbors(game_map, current):
            tentative_g_score = g_score[current] + 1
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, rounded_goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return []



--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\camera.py
from Settings.setup import MAX_ZOOM, MIN_ZOOM
from Controller.utils import screen_to_tile, tile_to_screen

class Camera:
    def __init__(self, width, height):
        self.offset_x = 0
        self.offset_y = 0
        self.zoom = MIN_ZOOM
        self.width = width
        self.height = height
        self.min_x = None
        self.max_x = None
        self.min_y = None
        self.max_y = None

    def apply(self, x, y):
        # Apply camera transformations to coordinates
        x = (x + self.offset_x) * self.zoom + self.width / 2
        y = (y + self.offset_y) * self.zoom + self.height / 2
        return x, y

    def unapply(self, screen_x, screen_y):
        # Convert screen coordinates to world coordinates
        world_x = (screen_x - self.width / 2) / self.zoom - self.offset_x
        world_y = (screen_y - self.height / 2) / self.zoom - self.offset_y
        return world_x, world_y

    def move(self, dx, dy):
        # Move the camera by dx and dy
        self.offset_x += dx / self.zoom
        self.offset_y += dy / self.zoom
        self.limit_camera()

    def set_zoom(self, zoom_factor):
        # Set the zoom level within allowed limits
        self.zoom = max(MIN_ZOOM, min(zoom_factor, MAX_ZOOM))
        self.limit_camera()

    def set_bounds(self, min_x, max_x, min_y, max_y):
        # Set the camera bounds
        self.min_x = min_x
        self.max_x = max_x
        self.min_y = min_y
        self.max_y = max_y
        self.limit_camera()

    def limit_camera(self):
        # Limit the camera to the set bounds
        if self.min_x is None or self.max_x is None:
            return

        half_screen_width = self.width / (2 * self.zoom)
        half_screen_height = self.height / (2 * self.zoom)

        min_offset_x = - (self.max_x - half_screen_width)
        max_offset_x = - (self.min_x + half_screen_width)
        min_offset_y = - (self.max_y - half_screen_height)
        max_offset_y = - (self.min_y + half_screen_height)

        self.offset_x = max(min_offset_x, min(self.offset_x, max_offset_x))
        self.offset_y = max(min_offset_y, min(self.offset_y, max_offset_y))

    def zoom_out_to_global(self):
        # Center the camera on the entire map and zoom out
        self.offset_x = - (self.min_x + self.max_x) / 2
        self.offset_y = - (self.min_y + self.max_y) / 2
        
        zoom_factor = 0.5 
        self.zoom = zoom_factor * MIN_ZOOM
        
        self.zoom = max(MIN_ZOOM, min(self.zoom, MAX_ZOOM))
        self.limit_camera()

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\drawing.py
import pygame
import math
import colorsys
import time
from Settings.setup import (
    HALF_TILE_SIZE,
    MAP_PADDING,
    HEALTH_BAR_WIDTH,
    HEALTH_BAR_HEIGHT,
    HEALTH_BAR_OFFSET_Y,
    UNIT_HITBOX
)
from Controller.utils import *
from Controller.init_assets import *
from Controller.gui import get_scaled_gui

def draw_map(screen, screen_width, screen_height, game_map, camera, players, team_colors, game_state, delta_time):
    corners_screen = [
        (0, 0),
        (screen_width, 0),
        (0, screen_height),
        (screen_width, screen_height)
    ]
    tile_indices = [
        screen_to_tile(
            sx, sy, 
            screen_width, screen_height, 
            camera,
            HALF_TILE_SIZE / 2, 
            HALF_TILE_SIZE / 4
        ) 
        for sx, sy in corners_screen
    ]

    x_candidates = [t[0] for t in tile_indices]
    y_candidates = [t[1] for t in tile_indices]

    margin = 5
    min_tile_x = max(0, min(x_candidates) - margin)
    max_tile_x = min(game_map.num_tiles_x - 1, max(x_candidates) + margin)
    min_tile_y = max(0, min(y_candidates) - margin)
    max_tile_y = min(game_map.num_tiles_y - 1, max(y_candidates) + margin)

    visible_entities = set()
    for tile_y in range(min_tile_y, max_tile_y):
        for tile_x in range(min_tile_x, max_tile_x):
            # Fill grass
            if tile_x % 10 == 0 and tile_y % 10 == 0:
                grass_sx, grass_sy = tile_to_screen(
                    tile_x + 4.5, 
                    tile_y + 4.5, 
                    HALF_TILE_SIZE, 
                    HALF_TILE_SIZE / 2,
                    camera,
                    screen_width,
                    screen_height
                )
                fill_grass(screen, grass_sx, grass_sy, camera)

            entity_set_active = game_map.grid.get((tile_x, tile_y), None)
            entity_set_inactive = game_map.inactive_matrix.get((tile_x, tile_y), None)

            if entity_set_active:
                for ent in entity_set_active:
                    visible_entities.add(ent)
            if entity_set_inactive:
                for ent_inactive in entity_set_inactive:
                    visible_entities.add(ent_inactive)

    visible_list = list(visible_entities)
    visible_list.sort(key=lambda e: (e.y, e.x))

    game_state['train_button_rects'] = {}
    current_time = time.time()

    # Draw entities
    for entity in visible_list:
        entity.display_hitbox(screen, screen_width, screen_height, camera)
        entity.display(screen, screen_width, screen_height, camera, delta_time)
        entity.display_range(screen, screen_width, screen_height, camera)

        if hasattr(entity, 'spawnsUnits') and entity.spawnsUnits:
            ent_screen_x, ent_screen_y = tile_to_screen(
                entity.x, 
                entity.y, 
                HALF_TILE_SIZE, 
                HALF_TILE_SIZE / 2,
                camera,
                screen_width,
                screen_height
            )
            
            # Always show training progress if there's an active training
            if entity.current_training_unit:
                bar_width = 80
                bar_height = 6
                button_width = 120
                offset_y = 12 * entity.size
                button_x = int(ent_screen_x - button_width / 2)
                button_y = int(ent_screen_y - offset_y - 10)
                bar_x = button_x
                bar_y = button_y - 10

                # Draw progress bar
                pygame.draw.rect(screen, (50, 50, 50), (bar_x, bar_y, bar_width, bar_height))
                fill_w = int(bar_width * entity.training_progress)
                pygame.draw.rect(screen, (0, 220, 0), (bar_x, bar_y, fill_w, bar_height))

                # Draw queue length
                font_obj = pygame.font.Font(None, 18)
                queue_len = len(entity.training_queue)
                queue_text = f"Q:{queue_len}"
                queue_surf = font_obj.render(queue_text, True, (255, 255, 255))
                screen.blit(queue_surf, (bar_x + bar_width + 5, bar_y - 2))

            # Only show training button and feedback when selected
            if 'selected_entities' in game_state and entity in game_state['selected_entities']:
                button_width = 120
                button_height = 25
                ent_screen_x, ent_screen_y = tile_to_screen(
                    entity.x, 
                    entity.y, 
                    HALF_TILE_SIZE, 
                    HALF_TILE_SIZE / 2,
                    camera,
                    screen_width,
                    screen_height
                )
                offset_y = 12 * entity.size
                button_x = int(ent_screen_x - button_width / 2)
                button_y = int(ent_screen_y - offset_y - 10)

                button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
                pygame.draw.rect(screen, (120, 120, 180), button_rect)
                font_obj = pygame.font.Font(None, 18)

                from Entity.Building.Building import UNIT_TRAINING_MAP
                if entity.acronym in UNIT_TRAINING_MAP:
                    unit_key = UNIT_TRAINING_MAP[entity.acronym]
                    button_text = f"Train {unit_key.capitalize()}"
                else:
                    button_text = "Train ???"

                text_surf = font_obj.render(button_text, True, (255, 255, 255))
                screen.blit(text_surf, text_surf.get_rect(center=button_rect.center))

                game_state['train_button_rects'][entity.entity_id] = button_rect

                # If not enough resources feedback
                if 'insufficient_resources_feedback' in game_state:
                    if entity.entity_id in game_state['insufficient_resources_feedback']:
                        start_time = game_state['insufficient_resources_feedback'][entity.entity_id]
                        if current_time - start_time < 3:
                            warn_text = "Not enough resources"
                            warn_surf = font_obj.render(warn_text, True, (255, 50, 50))
                            screen.blit(warn_surf, (button_x, button_y - 22))
                        else:
                            game_state['insufficient_resources_feedback'].pop(entity.entity_id, None)

    # Draw selection rectangle if needed
    if game_state.get('selecting_entities', False):
        start_pos = game_state.get('selection_start')
        end_pos = game_state.get('selection_end')
        if start_pos and end_pos:
            x1, y1 = start_pos
            x2, y2 = end_pos
            selection_rect = pygame.Rect(x1, y1, x2 - x1, y2 - y1)
            selection_rect.normalize()
            pygame.draw.rect(screen, (255, 255, 255), selection_rect, 1)

    # Health bars
    show_all_bars = game_state.get('show_all_health_bars', False)
    if show_all_bars:
        for entity in visible_list:
            color_val = get_entity_bar_color(entity, game_state, team_colors)
            entity.display_healthbar(screen, screen_width, screen_height, camera, color_val)
    else:
        selected_entities = game_state.get('selected_entities', [])
        for entity in visible_list:
            if entity in selected_entities or entity.hp < entity.max_hp:
                color_val = get_entity_bar_color(entity, game_state, team_colors)
                entity.display_healthbar(screen, screen_width, screen_height, camera, color_val)

def create_minimap_background(game_map, minimap_width, minimap_height):
    surface_map = pygame.Surface((minimap_width, minimap_height), pygame.SRCALPHA)
    surface_map.fill((0, 0, 0, 0))

    tile_width = HALF_TILE_SIZE
    tile_height = HALF_TILE_SIZE / 2
    nx = game_map.num_tiles_x
    ny = game_map.num_tiles_y

    corner_coords = [
        to_isometric(0, 0, tile_width, tile_height),
        to_isometric(0, ny - 1, tile_width, tile_height),
        to_isometric(nx - 1, ny - 1, tile_width, tile_height),
        to_isometric(nx - 1, 0, tile_width, tile_height)
    ]
    iso_xs = [c[0] for c in corner_coords]
    iso_ys = [c[1] for c in corner_coords]
    min_iso_x = min(iso_xs)
    max_iso_x = max(iso_xs)
    min_iso_y = min(iso_ys)
    max_iso_y = max(iso_ys)

    iso_map_width = max_iso_x - min_iso_x
    iso_map_height = max_iso_y - min_iso_y
    scale_factor = min(minimap_width / iso_map_width, minimap_height / iso_map_height)
    scaled_width = iso_map_width * scale_factor
    scaled_height = iso_map_height * scale_factor
    offset_x = (minimap_width - scaled_width) / 2
    offset_y = (minimap_height - scaled_height) / 2

    return surface_map, scale_factor, offset_x, offset_y, min_iso_x, min_iso_y

def display_fps(screen, clock, font):
    fps_value = f"{clock.get_fps():.2f}"  # Format to 2 decimal places
    fps_surface = font.render(fps_value, True, (255, 255, 255))  # White text
    screen.blit(fps_surface, (10, 10))  # (x, y) coordinates for top-left

def draw_pointer(screen):
    from Controller.gui import get_scaled_gui  # Déplacé ici pour éviter l'import circulaire
    mouse_x, mouse_y = pygame.mouse.get_pos()
    pointer_image = get_scaled_gui('pointer', 0, target_width=30)
    pointer_rect = pointer_image.get_rect(center=(mouse_x + pointer_image.get_width() //2, mouse_y + pointer_image.get_height() //2))
    screen.blit(pointer_image, pointer_rect.topleft)

def draw_healthBar(screen, screen_x, screen_y, ratio, color_val):
    bg_rect = pygame.Rect(
        screen_x - HEALTH_BAR_WIDTH // 2,
        screen_y - HEALTH_BAR_OFFSET_Y,
        HEALTH_BAR_WIDTH,
        HEALTH_BAR_HEIGHT
    )
    pygame.draw.rect(screen, (50, 50, 50), bg_rect)
    fill_width = int(HEALTH_BAR_WIDTH * ratio)
    fill_rect = pygame.Rect(bg_rect.x, bg_rect.y, fill_width, HEALTH_BAR_HEIGHT)
    pygame.draw.rect(screen, color_val, fill_rect)

def draw_hitbox(screen, corners, zoom):
    if len(corners) != 4:
        raise ValueError("Hitbox must have exactly 4 corners.")
    scaled_corners = [(x * zoom, y * zoom) for x, y in corners]
    pygame.draw.polygon(screen, (255, 255, 255), corners, width=1)

def draw_path(screen, unit_center, screenPath, zoom, color):
    if len(screenPath) >= 2:
        pygame.draw.lines(screen, color, False, screenPath, max(1, int(4 * zoom)))
    pygame.draw.circle(screen, color, unit_center, int(5 * zoom))

def draw_sprite(screen, acronym, category, screen_x, screen_y, zoom, state=None, frame=0, variant=0, direction=0):
    name = Entity_Acronym[category][acronym]
    scaled_sprite = get_scaled_sprite(name, category, zoom, state, direction, frame, variant)
    if scaled_sprite is None:
        return
    scaled_width = scaled_sprite.get_width()
    scaled_height = scaled_sprite.get_height()
    screen.blit(scaled_sprite, (screen_x - scaled_width // 2, screen_y - scaled_height // 2))


def draw_gui_elements(screen, screen_width, screen_height):
    """
    Dessine le panneau de ressources (en haut) et autres éléments.
    """
    resources_panel_img = get_scaled_gui('ResourcesPanel', 0, target_width=screen_width // 2)
    screen.blit(resources_panel_img, (0, 0))

    pw, ph = resources_panel_img.get_width(), resources_panel_img.get_height()
    icon_scale_width = pw // 22

    # On place 3 icônes (gold, wood, food) alignées, petit offset vertical
    gold_img = get_scaled_gui('gold', 0, target_width=icon_scale_width)
    gold_x = 12
    screen.blit(gold_img, (gold_x, ph // 15))

    wood_img = get_scaled_gui('wood', 0, target_width=icon_scale_width)
    wood_x = gold_x + gold_img.get_width() + (2 * gold_img.get_width())
    screen.blit(wood_img, (wood_x, ph // 15))

    food_img = get_scaled_gui('food', 0, target_width=icon_scale_width)
    food_x = wood_x + wood_img.get_width() + (2 * wood_img.get_width())
    screen.blit(food_img, (food_x, ph // 15))

    # Minimap panel
    panel_width = int(screen_width * PANEL_RATIO)
    panel_height = int(screen_height * PANEL_RATIO)
    minimap_panel_sprite = get_scaled_gui('minimapPanel', 0, target_width=panel_width)
    minimap_panel_rect = get_centered_rect_in_bottom_right(
        panel_width, panel_height, screen_width, screen_height, MINIMAP_MARGIN
    )

    screen.blit(minimap_panel_sprite, minimap_panel_rect.topleft)


def draw_minimap_viewport(screen, camera, minimap_rect, scale, offset_x, offset_y, min_iso_x, min_iso_y):
    half_screen_w = camera.width / (2 * camera.zoom)
    half_screen_h = camera.height / (2 * camera.zoom)
    center_iso_x = -camera.offset_x
    center_iso_y = -camera.offset_y

    left_iso_x = center_iso_x - half_screen_w
    left_iso_y = center_iso_y - half_screen_h
    right_iso_x = center_iso_x + half_screen_w
    right_iso_y = center_iso_y + half_screen_h

    rect_left = (left_iso_x - min_iso_x) * scale + minimap_rect.x + offset_x
    rect_top = (left_iso_y - min_iso_y) * scale + minimap_rect.y + offset_y
    rect_right = (right_iso_x - min_iso_x) * scale + minimap_rect.x + offset_x
    rect_bottom = (right_iso_y - min_iso_y) * scale + minimap_rect.y + offset_y

    rect_width = rect_right - rect_left
    rect_height = rect_bottom - rect_top

    pygame.draw.rect(
        screen, 
        (255, 255, 255), 
        (rect_left, rect_top, rect_width, rect_height), 
        2
    )

def draw_minimap_viewport(screen, camera, minimap_rect, scale, offset_x, offset_y, min_iso_x, min_iso_y):
    half_screen_w = camera.width / (2 * camera.zoom)
    half_screen_h = camera.height / (2 * camera.zoom)
    center_iso_x = -camera.offset_x
    center_iso_y = -camera.offset_y

    left_iso_x = center_iso_x - half_screen_w
    left_iso_y = center_iso_y - half_screen_h
    right_iso_x = center_iso_x + half_screen_w
    right_iso_y = center_iso_y + half_screen_h

    rect_left = (left_iso_x - min_iso_x) * scale + minimap_rect.x + offset_x
    rect_top = (left_iso_y - min_iso_y) * scale + minimap_rect.y + offset_y
    rect_right = (right_iso_x - min_iso_x) * scale + minimap_rect.x + offset_x
    rect_bottom = (right_iso_y - min_iso_y) * scale + minimap_rect.y + offset_y

    rect_width = rect_right - rect_left
    rect_height = rect_bottom - rect_top

    pygame.draw.rect(
        screen, 
        (255, 255, 255), 
        (rect_left, rect_top, rect_width, rect_height), 
        2
    )

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\event_handler.py
import pygame
import sys
import os
import time
from tkinter import Tk, filedialog
from Entity.Building import Building, TownCentre
from Settings.setup import HALF_TILE_SIZE, SAVE_DIRECTORY, MINIMAP_MARGIN, PANEL_RATIO, BG_RATIO
from Controller.utils import *
from Controller.drawing import compute_map_bounds, generate_team_colors
from Models.html import write_full_html
from AiUtils.aStar import a_star
from Entity.Unit.Unit import Unit
from Controller.terminal_display_debug import debug_print


def handle_events(event, game_state):
    """
    Gère les événements côté GUI/Pygame. 
    (Touches Pygame, clic souris, resize fenêtre, etc.)
    """
    camera = game_state['camera']
    players = game_state['players']
    selected_player = game_state['selected_player']
    screen_width = game_state['screen_width']
    screen_height = game_state['screen_height']

    if event.type == pygame.QUIT:
        # On supprime éventuellement la snapshot HTML
        try:
            os.remove('full_snapshot.html')
        except:
            pass
        pygame.quit()
        sys.exit()

    elif event.type == pygame.VIDEORESIZE:
        # Redimension de la fenêtre => on réadapte la taille, le minimap, etc.
        sw, sh = event.size
        camera.width = sw
        camera.height = sh

        panel_width  = int(sw * PANEL_RATIO)
        panel_height = int(sh * PANEL_RATIO)

        from Controller.init_assets import get_scaled_gui
        minimap_panel_sprite = get_scaled_gui('minimapPanel', 0, target_width=panel_width)
        game_state['minimap_panel_sprite'] = minimap_panel_sprite

        from Controller.drawing import create_minimap_background
        from Controller.utils import get_centered_rect_in_bottom_right

        new_panel_rect = get_centered_rect_in_bottom_right(
            panel_width, 
            panel_height, 
            sw, 
            sh, 
            MINIMAP_MARGIN
        )
        game_state['minimap_panel_rect'] = new_panel_rect

        bg_width  = int(sw * BG_RATIO)
        bg_height = int(sh * BG_RATIO)
        mb, ms, mo_x, mo_y, mi_x, mi_y = create_minimap_background(
            game_state['game_map'], bg_width, bg_height
        )

        game_state['minimap_background']     = mb
        game_state['minimap_scale']          = ms
        game_state['minimap_offset_x']       = mo_x
        game_state['minimap_offset_y']       = mo_y
        game_state['minimap_min_iso_x']      = mi_x
        game_state['minimap_min_iso_y']      = mi_y

        new_bg_rect = mb.get_rect()
        new_bg_rect.center = new_panel_rect.center
        new_bg_rect.y -= panel_height / 50
        new_bg_rect.x += panel_width / 18
        game_state['minimap_background_rect'] = new_bg_rect

        game_state['minimap_entities_surface'] = pygame.Surface(
            (mb.get_width(), mb.get_height()),
            pygame.SRCALPHA
        )
        game_state['minimap_entities_surface'].fill((0, 0, 0, 0))

        game_state['screen_width']  = sw
        game_state['screen_height'] = sh

        game_state['force_full_redraw'] = True
        game_state['player_selection_updated'] = True

        camera.limit_camera()
        return

    elif event.type == pygame.KEYDOWN:
        #
        # (1) - Touche F1 => bascule interface
        #
        if event.key == pygame.K_F1:
            game_state['show_gui_elements'] = not game_state['show_gui_elements']
            debug_print(f"[GUI] F1 => Show/Hide GUI elements={game_state['show_gui_elements']}")
            
        #
        # (2) - Touche F2 => bascule health bars
        #
        if event.key == pygame.K_F2:
            game_state['show_all_health_bars'] = not game_state['show_all_health_bars']
            debug_print(f"[GUI] F2 => show_all_health_bars={game_state['show_all_health_bars']}")

        #
        # (2) - Touche F11 => Sauvegarde
        #
        elif event.key == pygame.K_F11:
            game_state['game_map'].save_map()
            debug_print("[GUI] F11 => Sauvegarde effectuée.")

        #
        # (3) - Touche F12 => Chargement
        #
        elif event.key == pygame.K_F12:
            debug_print("[GUI] F12 => Menu chargement (filedialog).")
            try:
                root = Tk()
                root.withdraw()
                chosen_path = filedialog.askopenfilename(
                    initialdir=SAVE_DIRECTORY,
                    filetypes=[("Pickle","*.pkl")]
                )
                root.destroy()
                if chosen_path:
                    from Controller.drawing import create_minimap_background, compute_map_bounds, generate_team_colors
                    from Models.Map import GameMap
                    game_state['game_map'] = GameMap(0, False, [], generate=False)
                    game_state['game_map'].load_map(chosen_path)
                    game_state['players'].clear()
                    game_state['players'].extend(game_state['game_map'].players)
                    if game_state['players']:
                        game_state['selected_player'] = game_state['players'][0]
                    else:
                        game_state['selected_player'] = None

                    game_state['team_colors'] = generate_team_colors(len(game_state['players']))
                    camera.offset_x = 0
                    camera.offset_y = 0
                    camera.zoom = 1.0
                    min_x, max_x, min_y, max_y = compute_map_bounds(game_state['game_map'])
                    camera.set_bounds(min_x, max_x, min_y, max_y)
                    game_state['force_full_redraw'] = True
                else:
                    debug_print("[GUI] F12 => Aucune sauvegarde choisie (annulé).")

            except Exception as e:
                debug_print(f"[GUI] Error loading: {e}")

        #
        # (4) - Zoom + / -
        #
        elif event.key in (pygame.K_PLUS, pygame.K_KP_PLUS):
            camera.set_zoom(camera.zoom * 1.1)
            debug_print("[GUI] Zoom avant via +")

        elif event.key in (pygame.K_MINUS, pygame.K_KP_MINUS):
            camera.set_zoom(camera.zoom / 1.1)
            debug_print("[GUI] Zoom arrière via -")

        #
        # (5) - Touche m => Zoom out global (on se recadre)
        #
        elif event.key == pygame.K_m:
            camera.zoom_out_to_global()
            debug_print("[GUI] m => Camera zoom out global.")

        #
        # (6) - Touche ESC => on quitte l'application
        #
        elif event.key == pygame.K_ESCAPE:
            try:
                os.remove('full_snapshot.html')
            except:
                pass
            debug_print("[GUI] ESC => Quitte le jeu.")
            pygame.quit()
            sys.exit()

        #
        # (7) - Mouvements Terminal si on est en mode terminal/both
        #       => on modifie terminal_view_x / y
        #
        elif event.key == pygame.K_F3:
            game_state['show_player_info'] = not game_state['show_player_info']
        else:
            from Settings.setup import user_choices
            # Vérifie si c'est le mode Terminal or Both
            if user_choices["index_terminal_display"] in [1, 2]:
                if game_state['game_map'] and game_state['game_map'].game_state:
                    terminal_map = game_state['game_map']
                    move_amount = 1
                    mods = pygame.key.get_mods()
                    if mods & pygame.KMOD_SHIFT:
                        move_amount = 5
                        debug_print("[CURSES] SHIFT => scroll accéléré")

                    if event.key in [pygame.K_z, pygame.K_UP]:
                        terminal_map.terminal_view_y -= move_amount
                    elif event.key in [pygame.K_s, pygame.K_DOWN]:
                        terminal_map.terminal_view_y += move_amount
                    elif event.key in [pygame.K_q, pygame.K_LEFT]:
                        terminal_map.terminal_view_x -= move_amount
                    elif event.key in [pygame.K_d, pygame.K_RIGHT]:
                        terminal_map.terminal_view_x += move_amount
                    elif event.key == pygame.K_m:
                        # Recentrer la vue curses
                        debug_print("[CURSES] M => recentrage curses")
                        half_w = terminal_map.num_tiles_x // 2
                        half_h = terminal_map.num_tiles_y // 2
                        # Suppose qu'on veut recadrer la "fenêtre"
                        # centrée sur la map (juste un exemple)
                        # On peut adapter
                        terminal_map.terminal_view_x = max(0, half_w - 40)
                        terminal_map.terminal_view_y = max(0, half_h - 15)

    #
    # (8) - KEYUP => Touche Tab => on pause/unpause
    #
    elif event.type == pygame.KEYUP:
        if event.key == pygame.K_TAB:
            game_state['paused'] = not game_state.get('paused', False)
            if game_state['paused']:
                write_full_html(game_state['players'], game_state['game_map'])
                debug_print("[GUI] TAB => Pause activée, snapshot générée.")
            else:
                debug_print("[GUI] TAB => Unpause => reprise du jeu.")

    #idem avec P mais sans la snapshot
    elif event.type == pygame.KEYUP:
        if event.key == pygame.K_p:
            game_state['paused'] = not game_state.get('paused', False)
            if game_state['paused']:
                debug_print("[GUI] 'p' => Pause activée.")
            else:
                debug_print("[GUI] 'p' => Unpause => reprise du jeu.")

    #
    # (9) - MOUSEBUTTONDOWN
    #
    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_x, mouse_y = event.pos
        mods = pygame.key.get_mods()
        ctrl_pressed = (mods & pygame.KMOD_CTRL)

        if event.button == 1:
            # On check si on clique sur la minimap
            if game_state['minimap_background_rect'].collidepoint(mouse_x, mouse_y):
                game_state['minimap_dragging'] = True
            else:
                # Bouton "Train"
                train_rects = game_state.get('train_button_rects', {})
                clicked_building_id = None
                for bld_id, rect in train_rects.items():
                    if rect.collidepoint(mouse_x, mouse_y):
                        clicked_building_id = bld_id
                        break

                if clicked_building_id is not None:
                    building_clicked = find_entity_by_id(game_state, clicked_building_id)
                    if building_clicked and selected_player:
                        if building_clicked.team == selected_player.teamID:
                            success = building_clicked.add_to_training_queue(selected_player)
                            game_state['player_info_updated'] = True
                            if not success:
                                if 'insufficient_resources_feedback' not in game_state:
                                    game_state['insufficient_resources_feedback'] = {}
                                game_state['insufficient_resources_feedback'][building_clicked.entity_id] = time.time()
                else:
                    # Clique "normal" => sélectionner un entity ou drag box
                    entity = closest_entity(game_state, mouse_x, mouse_y)
                    if entity:
                        select_single_entity(entity, game_state, ctrl_pressed)
                        if hasattr(entity, 'notify_clicked'):
                            entity.notify_clicked()
                    else:
                        handle_left_click_on_panels_or_start_box_selection(
                            mouse_x, 
                            mouse_y, 
                            game_state, 
                            ctrl_pressed
                        )

        elif event.button == 3:
            # Clic droit => set target
            if selected_player and 'selected_units' in game_state and len(game_state['selected_units']) > 0:
                entity_target = closest_entity(game_state, mouse_x, mouse_y)
                for unit_selected in game_state['selected_units']:
                    unit_selected.set_target(entity_target)
                    unit_selected.path = None
                # On calcule la destination en 2.5D
                mouse_x, mouse_y = screen_to_2_5d(
                    mouse_x, mouse_y, screen_width, screen_height,
                    camera, HALF_TILE_SIZE, HALF_TILE_SIZE / 2
                )
                for unit_selected in game_state['selected_units']:
                    unit_selected.set_destination((mouse_x, mouse_y), game_state['game_map'])

        elif event.button == 4:  # molette haut => zoom avant
            camera.set_zoom(camera.zoom * 1.1)
            debug_print("[GUI] molette haut => zoom avant")

        elif event.button == 5:  # molette bas => zoom arrière
            camera.set_zoom(camera.zoom / 1.1)
            debug_print("[GUI] molette bas => zoom arrière")

    #
    # (10) - MOUSEMOTION
    #
    elif event.type == pygame.MOUSEMOTION:
        if game_state['minimap_dragging']:
            current_x, current_y = event.pos
            mini_rect = game_state['minimap_background_rect']
            local_x = current_x - mini_rect.x
            local_y = current_y - mini_rect.y

            scale = game_state['minimap_scale']
            offset_x = game_state['minimap_offset_x']
            offset_y = game_state['minimap_offset_y']
            map_min_iso_x = game_state['minimap_min_iso_x']
            map_min_iso_y = game_state['minimap_min_iso_y']

            iso_x = (local_x - offset_x) / scale + map_min_iso_x
            iso_y = (local_y - offset_y) / scale + map_min_iso_y

            camera.offset_x = -iso_x
            camera.offset_y = -iso_y
            camera.limit_camera()
        else:
            # Drag box pour la sélection de multiples entités
            if game_state.get('selecting_entities', False):
                game_state['selection_end'] = event.pos

    #
    # (11) - MOUSEBUTTONUP
    #
    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button == 1:
            game_state['minimap_dragging'] = False
            if game_state.get('selecting_entities'):
                finalize_box_selection(game_state)


def select_single_entity(entity, game_state, ctrl_pressed):
    if 'selected_entities' not in game_state:
        game_state['selected_entities'] = []
    if 'selected_units' not in game_state:
        game_state['selected_units'] = []

    if not ctrl_pressed:
        game_state['selected_entities'].clear()
        game_state['selected_units'].clear()

    if entity not in game_state['selected_entities']:
        game_state['selected_entities'].append(entity)

    selected_player = game_state['selected_player']
    if selected_player and isinstance(entity, Unit):
        if entity.team == selected_player.teamID:
            if entity not in game_state['selected_units']:
                game_state['selected_units'].append(entity)


def handle_left_click_on_panels_or_start_box_selection(mouse_x, mouse_y, game_state, ctrl_pressed=False):
    players = game_state['players']
    screen_height = game_state['screen_height']
    minimap_rect = game_state['minimap_background_rect']
    button_height = 30
    padding = 5
    max_display_height = screen_height / 3

    columns = 1
    while columns <= 4:
        rows = (len(players) + columns - 1) // columns
        total_height = button_height * rows + padding * (rows - 1)
        if total_height <= max_display_height or columns == 4:
            break
        columns += 1

    button_width = (minimap_rect.width - padding * (columns - 1)) // columns
    rows = (len(players) + columns - 1) // columns
    total_height = button_height * rows + padding * (rows - 1)

    base_x = minimap_rect.x
    base_y = minimap_rect.y - total_height - padding

    camera = game_state['camera']
    clicked_player_panel = False

    from Controller.utils import to_isometric
    from Entity.Building import TownCentre

    # Vérifie si on a cliqué sur le panel "joueurs"
    for index, player_obj in enumerate(reversed(players)):
        col = index % columns
        row = index // columns
        rect_x = base_x + col * (button_width + padding)
        rect_y = base_y + row * (button_height + padding)
        panel_rect = pygame.Rect(rect_x, rect_y, button_width, button_height)

        if panel_rect.collidepoint(mouse_x, mouse_y):
            if game_state['selected_player'] != player_obj:
                game_state['selected_player'] = player_obj
                game_state['player_selection_updated'] = True
                game_state['player_info_updated'] = True
                # On centre la caméra sur le TownCentre s’il existe
                for building_obj in player_obj.buildings:
                    if isinstance(building_obj, TownCentre):
                        iso_x, iso_y = to_isometric(
                            building_obj.x, 
                            building_obj.y, 
                            HALF_TILE_SIZE, 
                            HALF_TILE_SIZE / 2
                        )
                        camera.offset_x = -iso_x
                        camera.offset_y = -iso_y
                        camera.limit_camera()
                        break
            clicked_player_panel = True
            break

    if not clicked_player_panel:
        # On commence peut-être une zone de sélection
        game_state['selecting_entities'] = True
        game_state['selection_start'] = (mouse_x, mouse_y)
        game_state['selection_end'] = (mouse_x, mouse_y)
        game_state['box_additive'] = ctrl_pressed


def finalize_box_selection(game_state):
    import pygame
    from Controller.utils import tile_to_screen

    x1, y1 = game_state['selection_start']
    x2, y2 = game_state['selection_end']
    select_rect = pygame.Rect(x1, y1, x2 - x1, y2 - y1)
    select_rect.normalize()

    game_state['selecting_entities'] = False
    game_state['selection_start'] = None
    game_state['selection_end'] = None

    if 'selected_entities' not in game_state:
        game_state['selected_entities'] = []
    if 'selected_units' not in game_state:
        game_state['selected_units'] = []

    if not game_state.get('box_additive', False):
        game_state['selected_entities'].clear()
        game_state['selected_units'].clear()

    selected_player = game_state['selected_player']
    if not selected_player:
        return

    screen_width = game_state['screen_width']
    screen_height = game_state['screen_height']
    camera = game_state['camera']
    game_map = game_state['game_map']

    # On récupère toutes les entités sur la map
    all_entities = set()
    for entities_set in game_map.grid.values():
        for entity_obj in entities_set:
            all_entities.add(entity_obj)

    # On regarde lesquelles sont dans la zone
    for entity_obj in all_entities:
        screen_x, screen_y = tile_to_screen(
            entity_obj.x, 
            entity_obj.y,
            HALF_TILE_SIZE, 
            HALF_TILE_SIZE / 2,
            camera, 
            screen_width, 
            screen_height
        )
        if select_rect.collidepoint(screen_x, screen_y):
            if entity_obj not in game_state['selected_entities']:
                game_state['selected_entities'].append(entity_obj)

            if isinstance(entity_obj, Unit) and entity_obj.team == selected_player.teamID:
                if entity_obj not in game_state['selected_units']:
                    game_state['selected_units'].append(entity_obj)


def closest_entity(game_state, mouse_x, mouse_y, search_radius=2):
    game_map = game_state['game_map']
    camera = game_state['camera']
    screen_width = game_state['screen_width']
    screen_height = game_state['screen_height']
    mouse_2_5d = screen_to_2_5d(mouse_x, mouse_y, screen_width, screen_height, camera, HALF_TILE_SIZE, HALF_TILE_SIZE/2)

    tile_x, tile_y = screen_to_tile(
        mouse_x, mouse_y, 
        screen_width, screen_height, 
        camera, 
        HALF_TILE_SIZE / 2, 
        HALF_TILE_SIZE / 4
    )
    entity_set = game_map.grid.get((tile_x, tile_y), [])
    shortest_distance = 999999
    closest_ent = None
    for entity in entity_set:
        distance = math.dist(mouse_2_5d, (entity.x, entity.y)) - entity.hitbox
        if distance < shortest_distance:
            shortest_distance = distance
            closest_ent = entity
    return closest_ent


def find_entity_by_id(game_state, entity_id):
    game_map = game_state['game_map']
    for position, entity_set in game_map.grid.items():
        for entity_obj in entity_set:
            if entity_obj.entity_id == entity_id:
                return entity_obj

    for position, entity_set in game_map.inactive_matrix.items():
        for entity_obj in entity_set:
            if entity_obj.entity_id == entity_id:
                return entity_obj
    return None


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\game_loop.py
import time
import pygame
import sys
import random
from Models.Map import GameMap
from Entity.Building import *
from Entity.Unit import *
from Models.Team import Team
from Controller.camera import Camera
from Controller.terminal_display_debug import debug_print
from Controller.drawing import (
    draw_map,
    compute_map_bounds,
    create_minimap_background,
    display_fps,
    generate_team_colors,
    draw_pointer,
    draw_gui_elements,
    draw_minimap_viewport
)
import copy
from Controller.event_handler import handle_events
from Controller.update import update_game_state
from Controller.gui import (
    create_player_selection_surface,
    create_player_info_surface,
    get_scaled_gui,
    get_centered_rect_in_bottom_right,
    update_minimap_elements,
)
from Controller.utils import tile_to_screen
from Settings.setup import (
    HALF_TILE_SIZE,
    MINIMAP_MARGIN,
    UPDATE_EVERY_N_MILLISECOND,
    user_choices,
    GAME_SPEED,
    PANEL_RATIO,
    BG_RATIO,
    ONE_SECOND,
    FPS_DRAW_LIMITER
)

def is_player_dead(player):
    # Simple check: no units, no buildings, and zero resources to rebuild
    if not player.units and not player.buildings:
        if (player.resources.food <= 50 and
            player.resources.gold <= 225):
            return True
    return False

def draw_game_over_overlay(screen, game_state):
    font = pygame.font.SysFont(None, 48)
    text = font.render(f"Joueur {game_state['winner_id']} est gagnant!", True, (255, 255, 255))
    text_rect = text.get_rect(center=(game_state['screen_width'] // 2, game_state['screen_height'] // 2 - 50))
    screen.blit(text, text_rect)

    button_font = pygame.font.SysFont(None, 36)
    button_text = button_font.render("Quitter le jeu", True, (255, 255, 255))
    button_rect = button_text.get_rect(center=(game_state['screen_width'] // 2, game_state['screen_height'] // 2 + 50))
    pygame.draw.rect(screen, (0, 0, 0), button_rect.inflate(20, 10))
    screen.blit(button_text, button_rect)
    game_state['game_over_button_rect'] = button_rect

    # Nouveau bouton "Menu Principal"
    main_menu_text = button_font.render("Menu Principal", True, (255, 255, 255))
    main_menu_rect = main_menu_text.get_rect(
        center=(game_state['screen_width'] // 2, game_state['screen_height'] // 2 + 100)
    )
    pygame.draw.rect(screen, (0, 0, 0), main_menu_rect.inflate(20, 10))
    screen.blit(main_menu_text, main_menu_rect)
    game_state['main_menu_button_rect'] = main_menu_rect

def game_loop(screen, game_map, screen_width, screen_height, players):
    clock = pygame.time.Clock()
    pygame.key.set_repeat(0, 0)
    camera = Camera(screen_width, screen_height)
    team_colors = generate_team_colors(len(players))
    pygame.mouse.set_visible(False)
    font = pygame.font.SysFont(None, 24)

    min_iso_x, max_iso_x, min_iso_y, max_iso_y = compute_map_bounds(game_map)
    camera.set_bounds(min_iso_x, max_iso_x, min_iso_y, max_iso_y)

    panel_width  = int(screen_width * PANEL_RATIO)
    panel_height = int(screen_height * PANEL_RATIO)
    minimap_panel_sprite = get_scaled_gui('minimapPanel', 0, target_width=panel_width)
    minimap_panel_rect   = get_centered_rect_in_bottom_right(
        panel_width, panel_height, screen_width, screen_height, MINIMAP_MARGIN
    )

    bg_width  = int(screen_width * BG_RATIO)
    bg_height = int(screen_height * BG_RATIO)
    (
        minimap_background_surface,
        minimap_scale,
        minimap_offset_x,
        minimap_offset_y,
        minimap_min_iso_x,
        minimap_min_iso_y
    ) = create_minimap_background(game_map, bg_width, bg_height)

    minimap_background_rect = minimap_background_surface.get_rect()
    minimap_background_rect.center = minimap_panel_rect.center
    minimap_background_rect.y -= panel_height / 50
    minimap_background_rect.x += panel_width / 18
    minimap_entities_surface = pygame.Surface(
        (minimap_background_rect.width, minimap_background_rect.height),
        pygame.SRCALPHA
    )
    minimap_entities_surface.fill((0, 0, 0, 0))

    selected_player = players[0] if players else None
    fullscreen = False

    game_state = {
        'camera': camera,
        'players': players,
        'selected_player': selected_player,
        'team_colors': team_colors,
        'game_map': game_map,
        'minimap_panel_sprite': minimap_panel_sprite,
        'minimap_panel_rect': minimap_panel_rect,
        'minimap_background': minimap_background_surface,
        'minimap_background_rect': minimap_background_rect,
        'minimap_entities_surface': minimap_entities_surface,
        'minimap_scale': minimap_scale,
        'minimap_offset_x': minimap_offset_x,
        'minimap_offset_y': minimap_offset_y,
        'minimap_min_iso_x': minimap_min_iso_x,
        'minimap_min_iso_y': minimap_min_iso_y,
        'screen_width': screen_width,
        'screen_height': screen_height,
        'screen': screen,
        'fullscreen': fullscreen,
        'minimap_dragging': False,
        'player_selection_updated': True,
        'player_info_updated': True,
        'selected_entities': [],
        'selecting_entities': False,
        'selection_start': None,
        'selection_end': None,
        'rectangle_additive': False,
        'paused': False,
        'force_full_redraw': False,
        'show_all_health_bars': False,
        'show_player_info': True,
        'show_gui_elements': True,
        'return_to_menu': False,  # Nouveau flag
    }
    
    game_map.set_game_state(game_state)

    player_selection_surface = None
    player_info_surface = None

    running = True
    update_counter = 0

    old_resources = {}
    for p in players:
        old_resources[p.teamID] = p.resources.copy()

    draw_timer = 0
    while running:
        raw_dt = clock.tick(160) / ONE_SECOND
        dt = 0 if game_state['paused'] else raw_dt
        dt = dt * GAME_SPEED

        events = pygame.event.get()
        for event in events:
            handle_events(event, game_state)
            if event.type == pygame.QUIT:
                running = False
            if game_state.get('game_over', False):
                # On rend la souris visible pour cliquer sur les boutons
                pygame.mouse.set_visible(True)
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    mx, my = pygame.mouse.get_pos()
                    if 'game_over_button_rect' in game_state:
                        if game_state['game_over_button_rect'].collidepoint(mx, my):
                            user_choices["menu_result"] = "quit"
                            running = False
                    if 'main_menu_button_rect' in game_state:
                        if game_state['main_menu_button_rect'].collidepoint(mx, my):
                            user_choices["menu_result"] = "main_menu"
                            # Retour au menu
                            game_state['game_over'] = False
                            user_choices["validated"] = False
                            game_state['return_to_menu'] = True

        if game_state.get('return_to_menu'):
            # On sort de la boucle => retour menu
            break

        screen = game_state['screen']
        screen_width = game_state['screen_width']
        screen_height = game_state['screen_height']
        selected_player = game_state['selected_player']
        players = game_state['players']
        team_colors = game_state['team_colors']
        game_map = game_state['game_map']
        camera = game_state['camera']

        # Terminal only => pas d'affichage Pygame
        if user_choices["index_terminal_display"] == 1:
            screen = None

        # Mise à jour (logique)
        if not game_state.get('paused', False):
            if update_counter > 1:
                update_counter = 0
                update_minimap_elements(game_state)
            update_counter += dt

        # Surfaces
        if not game_state.get('paused', False):
            if game_state.get('player_selection_updated', False):
                player_selection_surface = create_player_selection_surface(
                    players,
                    selected_player,
                    game_state['minimap_background_rect'],
                    team_colors
                )
                game_state['player_selection_updated'] = False

            if game_state.get('player_info_updated', False):
                player_info_surface = create_player_info_surface(
                    selected_player, screen_width, team_colors
                )
                game_state['player_info_updated'] = False

        update_game_state(game_state, dt)

        # Remove players who are dead
        for p in players[:]:
            if is_player_dead(p):
                debug_print(f"[GAME] Joueur {p.teamID} est éliminé.")
                players.remove(p)

        if len(players) == 1 and not game_state.get('game_over', False):
            debug_print(f"[GAME] Joueur {players[0].teamID} est gagnant.")
            game_state['winner_id'] = players[0].teamID
            game_state['game_over'] = True
            game_state['paused'] = True

        if selected_player is not None:
            current_res = selected_player.resources
            previous_res = old_resources[selected_player.teamID]
            if current_res != previous_res:
                game_state['player_info_updated'] = True
                old_resources[selected_player.teamID] = current_res.copy()

        # Rendu Pygame (GUI)
        draw_timer += raw_dt

        if screen is not None and draw_timer >= 1/FPS_DRAW_LIMITER:
            draw_timer = 0
            screen.fill((0, 0, 0))
            draw_map(
                screen,
                screen_width,
                screen_height,
                game_map,
                camera,
                players,
                team_colors,
                game_state,
                dt
            )
            
            if game_state['show_gui_elements']:
                draw_gui_elements(screen, screen_width, screen_height)
                screen.blit(game_state['minimap_background'], game_state['minimap_background_rect'].topleft)
                screen.blit(game_state['minimap_entities_surface'], game_state['minimap_background_rect'].topleft)
                draw_minimap_viewport(
                    screen,
                    camera,
                    game_state['minimap_background_rect'],
                    game_state['minimap_scale'],
                    game_state['minimap_offset_x'],
                    game_state['minimap_offset_y'],
                    game_state['minimap_min_iso_x'],
                    game_state['minimap_min_iso_y']
                )

                if player_selection_surface:
                    sel_h = player_selection_surface.get_height()
                    bg_rect = game_state['minimap_background_rect']
                    screen.blit(player_selection_surface, (bg_rect.x, bg_rect.y - sel_h - 20))

                if player_info_surface and game_state['show_player_info']:
                    inf_h = player_info_surface.get_height()
                    screen.blit(player_info_surface, (0, screen_height - inf_h))

            draw_pointer(screen)

            for pl in game_map.players:
                for unit in pl.units:
                    if unit.path:
                        unit.display_path(
                            game_state['screen'],
                            game_state['screen_width'],
                            game_state['screen_height'],
                            game_state['camera']
                        )
            display_fps(screen, clock, font)
            if game_state.get('game_over', False):
                draw_game_over_overlay(screen, game_state)
            if game_state.get('force_full_redraw', False):
                pygame.display.flip()
                game_state['force_full_redraw'] = False
            else:
                pygame.display.flip()

    # fin de game_loop


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\gui.py
import pygame
import os
import sys
import time
from collections import OrderedDict, Counter
from Settings.setup import *
from Controller.init_assets import *
from Settings.setup import HALF_TILE_SIZE, MINIMAP_MARGIN, PANEL_RATIO, BG_RATIO
from Controller.utils import to_isometric, get_color_for_terrain
from Entity.Building import Building

pygame.init()
font = pygame.font.SysFont(None, 32)

user_choices["index_terminal_display"] = 2

def get_scaled_gui(ui_name, variant=0, target_width=None, target_height=None):
    global gui_cache
    key = (ui_name, variant, target_width, target_height)
    if key in gui_cache:
        return gui_cache[key]

    original = gui_elements[ui_name][variant]
    ow, oh = original.get_width(), original.get_height()

    if target_width and not target_height:
        ratio = target_width / ow
        target_height = int(oh * ratio)
    elif target_height and not target_width:
        ratio = target_height / oh
        target_width = int(ow * ratio)
    elif not target_width and not target_height:
        # Pas de mise à l'échelle
        gui_cache[key] = original
        return original

    scaled = pygame.transform.smoothscale(original, (target_width, target_height))
    gui_cache[key] = scaled
    return scaled

def get_centered_rect_in_bottom_right(width, height, screen_width, screen_height, margin=10):
    rect = pygame.Rect(0, 0, width, height)
    center_x = screen_width - margin - (width // 2)
    center_y = screen_height - margin - (height // 2)
    rect.center = (center_x, center_y)
    return rect

def update_minimap_elements(game_state):
    from Entity.Building import Building
    from Entity.Resource.Gold import Gold

    camera = game_state['camera']
    game_map = game_state['game_map']
    team_colors = game_state['team_colors']
    scale_factor = game_state['minimap_scale']
    offset_x = game_state['minimap_offset_x']
    offset_y = game_state['minimap_offset_y']
    min_iso_x = game_state['minimap_min_iso_x']
    min_iso_y = game_state['minimap_min_iso_y']
    minimap_surface = game_state['minimap_entities_surface']

    minimap_surface.fill((0, 0, 0, 0))

    tile_width = HALF_TILE_SIZE
    tile_height = HALF_TILE_SIZE / 2

    entity_set = set()
    for pos, active_entities in game_map.grid.items():
        for ent in active_entities:
            entity_set.add(ent)

    MIN_BUILDING_SIZE = 3
    MIN_UNIT_RADIUS = 2

    for ent in entity_set:
        x_val, y_val = ent.x, ent.y
        iso_x, iso_y = to_isometric(x_val, y_val, tile_width, tile_height)
        mini_x = (iso_x - min_iso_x) * scale_factor + offset_x
        mini_y = (iso_y - min_iso_y) * scale_factor + offset_y

        if ent.team is not None:
            color_draw = team_colors[ent.team % len(team_colors)]
            if isinstance(ent, Building):
                half_dim = max(MIN_BUILDING_SIZE, ent.size)
                rect_building = pygame.Rect(
                    mini_x - half_dim, 
                    mini_y - half_dim, 
                    half_dim * 2, 
                    half_dim * 2
                )
                pygame.draw.rect(minimap_surface, (*color_draw, 150), rect_building)
            else:
                radius_val = max(MIN_UNIT_RADIUS, ent.size)
                pygame.draw.circle(minimap_surface, (*color_draw, 150), (mini_x, mini_y), radius_val)
        else:
            if isinstance(ent, Gold):
                gold_color = get_color_for_terrain('gold')
                radius_val = max(MIN_UNIT_RADIUS, ent.size)
                pygame.draw.circle(minimap_surface, (*gold_color, 150), (mini_x, mini_y), radius_val)

def run_gui_menu(screen, sw, sh):
    """
    Menu GUI bloquant : boucle Pygame jusqu'à ce que user_choices["validated"] == True
    ou fermeture de la fenêtre.

    Par défaut, toggle_button["index"] = 2 => Both (Terminal + GUI).
    """
    clock = pygame.time.Clock()
    show_main_menu   = True
    show_config_menu = False
    show_load_menu   = False

    main_buttons = [
        {"text": "Nouvelle Partie", "rect": pygame.Rect(0,0,200,50)},
        {"text": "Charger Partie",  "rect": pygame.Rect(0,0,200,50)},
        {"text": "Quitter",         "rect": pygame.Rect(0,0,200,50)},
    ]
    
    back_button = {"text": "Retour", "rect": pygame.Rect(20, 20, 100, 40)}

    # On force la valeur par défaut à "Both" = index = 2
    toggle_button = {
        "rect": pygame.Rect(sw // 2 - 200, 400, 400, 50),
        "texts": ["Gui ONLY", "Terminal Display ONLY", "Terminal and Gui Display"],
        "index": 2  # => Both
    }

    save_files = []
    if os.path.isdir(SAVE_DIRECTORY):
        save_files = [f for f in os.listdir(SAVE_DIRECTORY) if f.endswith('.pkl')]

    if user_choices["grid_size"] not in VALID_GRID_SIZES:
        user_choices["grid_size"] = VALID_GRID_SIZES[0]
    idx_grid = VALID_GRID_SIZES.index(user_choices["grid_size"])
    idx_nbot = VALID_BOTS_COUNT.index(user_choices["num_bots"])
    idx_lvl  = VALID_LEVELS.index(user_choices["bot_level"])

    gold_checked = user_choices["gold_at_center"]
    combo_open = None

    running = True
    while running:
        clock.tick(60)
        screen.fill((30,30,30))

        if user_choices["validated"]:
            running = False

        mx, my = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            elif event.type == pygame.MOUSEWHEEL:
                if combo_open == "grid":
                    if event.y < 0:
                        if combo_scroll_positions["grid"] < len(VALID_GRID_SIZES) - MAX_VISIBLE_ITEMS:
                            combo_scroll_positions["grid"] += 1
                    else:
                        if combo_scroll_positions["grid"] > 0:
                            combo_scroll_positions["grid"] -= 1
                elif combo_open == "nbot":
                    if event.y < 0:
                        if combo_scroll_positions["nbot"] < len(VALID_BOTS_COUNT) - MAX_VISIBLE_ITEMS:
                            combo_scroll_positions["nbot"] += 1
                    else:
                        if combo_scroll_positions["nbot"] > 0:
                            combo_scroll_positions["nbot"] -= 1
                elif combo_open == "lvl":
                    if event.y < 0:
                        if combo_scroll_positions["lvl"] < len(VALID_LEVELS) - MAX_VISIBLE_ITEMS:
                            combo_scroll_positions["lvl"] += 1
                    else:
                        if combo_scroll_positions["lvl"] > 0:
                            combo_scroll_positions["lvl"] -= 1

            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                # Bouton "Retour"
                if (show_config_menu or show_load_menu) and back_button["rect"].collidepoint(mx, my):
                    show_main_menu = True
                    show_config_menu = False
                    show_load_menu = False
                    continue

                if combo_open == "grid":
                    start_idx = combo_scroll_positions["grid"]
                    visible_items = VALID_GRID_SIZES[start_idx:start_idx + MAX_VISIBLE_ITEMS]
                    item_height = ITEM_HEIGHT
                    expanded_rect = pygame.Rect(sw//2 - 100, 100 + item_height, 200, item_height * len(visible_items))
                    if expanded_rect.collidepoint(mx,my):
                        relative_y = my - (100 + item_height)
                        item_index = relative_y // item_height
                        if 0 <= item_index < len(visible_items):
                            new_val = visible_items[item_index]
                            idx_grid = VALID_GRID_SIZES.index(new_val)
                            user_choices["grid_size"] = new_val
                        combo_open = None
                        continue
                elif combo_open == "nbot":
                    start_idx = combo_scroll_positions["nbot"]
                    visible_items = VALID_BOTS_COUNT[start_idx:start_idx + MAX_VISIBLE_ITEMS]
                    expanded_rect = pygame.Rect(sw//2 - 100, 160 + ITEM_HEIGHT, 200, ITEM_HEIGHT * len(visible_items))
                    if expanded_rect.collidepoint(mx,my):
                        relative_y = my - (160 + ITEM_HEIGHT)
                        item_index = relative_y // ITEM_HEIGHT
                        if 0 <= item_index < len(visible_items):
                            new_val = visible_items[item_index]
                            idx_nbot = VALID_BOTS_COUNT.index(new_val)
                            user_choices["num_bots"] = new_val
                        combo_open = None
                        continue
                elif combo_open == "lvl":
                    start_idx = combo_scroll_positions["lvl"]
                    visible_items = VALID_LEVELS[start_idx:start_idx + MAX_VISIBLE_ITEMS]
                    expanded_rect = pygame.Rect(sw//2 - 100, 220 + ITEM_HEIGHT, 200, ITEM_HEIGHT * len(visible_items))
                    if expanded_rect.collidepoint(mx,my):
                        relative_y = my - (220 + ITEM_HEIGHT)
                        item_index = relative_y // ITEM_HEIGHT
                        if 0 <= item_index < len(visible_items):
                            new_val = visible_items[item_index]
                            idx_lvl = VALID_LEVELS.index(new_val)
                            user_choices["bot_level"] = new_val
                        combo_open = None
                        continue

                if combo_open:
                    combo_rect_grid = pygame.Rect(sw//2 - 100, 100, 200, 30)
                    combo_rect_nbot = pygame.Rect(sw//2 - 100, 160, 200, 30)
                    combo_rect_lvl  = pygame.Rect(sw//2 - 100, 220, 200, 30)

                    # Si on clique en dehors, on referme
                    if not (combo_rect_grid.collidepoint(mx,my) or 
                            combo_rect_nbot.collidepoint(mx,my) or 
                            combo_rect_lvl.collidepoint(mx,my)):
                        combo_open = None

                if show_main_menu:
                    for i, btn in enumerate(main_buttons):
                        if btn["rect"].collidepoint(mx,my):
                            if i == 0:
                                user_choices["load_game"] = False
                                show_main_menu = False
                                show_config_menu = True
                            elif i == 1:
                                user_choices["load_game"] = True
                                show_main_menu = False
                                show_load_menu = True
                            else:
                                pygame.quit()
                                sys.exit()

                elif show_config_menu:
                    combo_rect_grid = pygame.Rect(sw//2 - 100, 100, 200, 30)
                    combo_rect_nbot = pygame.Rect(sw//2 - 100, 160, 200, 30)
                    combo_rect_lvl  = pygame.Rect(sw//2 - 100, 220, 200, 30)
                    if combo_rect_grid.collidepoint(mx,my):
                        combo_open = ("grid" if combo_open != "grid" else None)
                    elif combo_rect_nbot.collidepoint(mx,my):
                        combo_open = ("nbot" if combo_open != "nbot" else None)
                    elif combo_rect_lvl.collidepoint(mx,my):
                        combo_open = ("lvl" if combo_open != "lvl" else None)

                    chk_rect = pygame.Rect(sw//2 - 100, 280, 30, 30)
                    if chk_rect.collidepoint(mx,my):
                        gold_checked = not gold_checked
                        user_choices["gold_at_center"] = gold_checked

                    valid_rect = pygame.Rect(sw//2 - 50, 340, 100, 40)
                    if valid_rect.collidepoint(mx,my):
                        user_choices["validated"] = True
                        running = False

                    # Insert toggle_button logic here
                    if toggle_button["rect"].collidepoint(mx, my):
                        toggle_button["index"] = (toggle_button["index"] + 1) % len(toggle_button["texts"])
                        user_choices["index_terminal_display"] = toggle_button["index"]

                elif show_load_menu:
                    start_y = 100
                    gap = 5
                    block_h = 30
                    for i, sf in enumerate(save_files):
                        rect = pygame.Rect(sw//2 - 150, start_y + i*(block_h+gap), 300, block_h)
                        if rect.collidepoint(mx,my):
                            user_choices["chosen_save"] = os.path.join(SAVE_DIRECTORY, sf)
                            user_choices["load_game"] = True
                            user_choices["validated"] = True
                            running = False

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    combo_open = None
        
        if show_main_menu:
            draw_main_menu(screen, sw, sh, main_buttons)
        elif show_config_menu:
            draw_config_menu(screen, sw, sh, idx_grid, idx_nbot, idx_lvl, gold_checked, combo_open)
            draw_choose_display(screen, toggle_button)
            pygame.draw.rect(screen, (100, 100, 200), back_button["rect"])
            txt = font.render(back_button["text"], True, (255,255,255))
            screen.blit(txt, txt.get_rect(center=back_button["rect"].center))

        elif show_load_menu:
            draw_load_menu(screen, sw, sh, save_files)
            pygame.draw.rect(screen, (100, 100, 200), back_button["rect"])
            txt = font.render(back_button["text"], True, (255,255,255))
            screen.blit(txt, txt.get_rect(center=back_button["rect"].center))

        pygame.display.flip()
        
        # Met à jour la variable globale index_terminal_display
        # d'après l'état du bouton toggle_button
        user_choices["index_terminal_display"] = toggle_button["index"]

def draw_choose_display(screen, toggle_button):
    pygame.draw.rect(screen, (0, 122, 255), toggle_button["rect"])
    font = pygame.font.Font(None, 36)
    text_surface = font.render(toggle_button["texts"][toggle_button["index"]], True, (255, 255, 255))
    text_rect = text_surface.get_rect(center=toggle_button["rect"].center)
    screen.blit(text_surface, text_rect)

def draw_main_menu(screen, sw, sh, buttons):
    gap = 20
    start_y = (sh - (len(buttons)*50 + gap*(len(buttons)-1))) // 2
    for i, btn in enumerate(buttons):
        btn["rect"].centerx = sw//2
        btn["rect"].y = start_y + i*(50+gap)
        pygame.draw.rect(screen, (100, 100, 200), btn["rect"])
        txt = font.render(btn["text"], True, (255,255,255))
        screen.blit(txt, txt.get_rect(center=btn["rect"].center))

def draw_config_menu(screen, sw, sh, idx_grid, idx_nbot, idx_lvl, gold_checked, combo_open):
    if combo_open != "grid":
        draw_combo_box(screen, sw//2 - 100, 100, 200, 30, f"Taille: {VALID_GRID_SIZES[idx_grid]}", None, idx_grid)
    if combo_open != "nbot":
        draw_combo_box(screen, sw//2 - 100, 160, 200, 30, f"Bots: {VALID_BOTS_COUNT[idx_nbot]}", None, idx_nbot)
    if combo_open != "lvl":
        draw_combo_box(screen, sw//2 - 100, 220, 200, 30, f"Niveau: {VALID_LEVELS[idx_lvl]}", None, idx_lvl)

    chk_rect = pygame.Rect(sw//2 - 100, 280, 30, 30)
    pygame.draw.rect(screen, (200,200,200), chk_rect)
    if gold_checked:
        pygame.draw.line(screen, (0,0,0), (chk_rect.x+5, chk_rect.centery), (chk_rect.right-5, chk_rect.centery), 3)
    txt = font.render("Or au centre ?", True, (255,255,255))
    screen.blit(txt, (chk_rect.right+10, chk_rect.y))

    valid_rect = pygame.Rect(sw//2 - 50, 340, 100, 40)
    pygame.draw.rect(screen, (80,200,80), valid_rect)
    vtxt = font.render("Valider", True, (255,255,255))
    screen.blit(vtxt, vtxt.get_rect(center=valid_rect.center))

    if combo_open == "grid":
        draw_combo_box(screen, sw//2 - 100, 100, 200, 30, f"Taille: {VALID_GRID_SIZES[idx_grid]}",
                       VALID_GRID_SIZES, idx_grid, combo_type="grid")
    elif combo_open == "nbot":
        draw_combo_box(screen, sw//2 - 100, 160, 200, 30, f"Bots: {VALID_BOTS_COUNT[idx_nbot]}",
                       VALID_BOTS_COUNT, idx_nbot, combo_type="nbot")
    elif combo_open == "lvl":
        draw_combo_box(screen, sw//2 - 100, 220, 200, 30, f"Niveau: {VALID_LEVELS[idx_lvl]}",
                       VALID_LEVELS, idx_lvl, combo_type="lvl")

def draw_load_menu(screen, sw, sh, save_files):
    start_y = 100
    gap = 5
    block_h = 30
    txt = font.render("Choisissez la sauvegarde :", True, (255,255,255))
    screen.blit(txt, (sw//2 - txt.get_width()//2, 50))
    for i, sf in enumerate(save_files):
        rect = pygame.Rect(sw//2 - 150, start_y + i*(block_h+gap), 300, block_h)
        pygame.draw.rect(screen, (180,80,80), rect)
        txt2 = font.render(sf, True, (255,255,255))
        screen.blit(txt2, txt2.get_rect(center=rect.center))

def draw_combo_box(screen, x, y, w, h, text, items_list, selected_idx, combo_type=None):
    box_rect = pygame.Rect(x, y, w, h)
    pygame.draw.rect(screen, (60,60,160), box_rect)
    screen.blit(font.render(text, True, (255,255,255)), (x+5, y+3))

    if items_list:
        start_idx = combo_scroll_positions[combo_type]
        visible_items = items_list[start_idx:start_idx + MAX_VISIBLE_ITEMS]

        total_height = len(visible_items) * ITEM_HEIGHT
        shadow_surf = pygame.Surface((w, total_height))
        shadow_surf.set_alpha(160)
        shadow_surf.fill((0,0,0))
        screen.blit(shadow_surf, (x, y + h))

        for i, val in enumerate(visible_items):
            rect = pygame.Rect(x, y + h + i*ITEM_HEIGHT, w, ITEM_HEIGHT)
            pygame.draw.rect(screen, (60,60,120), rect)
            txt = font.render(str(val), True, (255,255,255))
            screen.blit(txt, txt.get_rect(center=rect.center))

        if len(items_list) > MAX_VISIBLE_ITEMS:
            scroll_bar_height = 50
            scroll_bar_x = x + w - 10
            scroll_bar_y = y + h
            scroll_track_height = total_height
            pygame.draw.rect(screen, (100,100,100), (scroll_bar_x, scroll_bar_y, 10, scroll_track_height))

            ratio = start_idx / float(len(items_list) - MAX_VISIBLE_ITEMS)
            cursor_y = scroll_bar_y + int(ratio * (scroll_track_height - scroll_bar_height))
            pygame.draw.rect(screen, (200,200,200), (scroll_bar_x, cursor_y, 10, scroll_bar_height))

def create_player_selection_surface(players, selected_player, minimap_rect, team_colors):
    selection_height = 30
    padding = 5

    screen = pygame.display.get_surface()
    screen_height = screen.get_height()
    max_height = screen_height / 3

    columns = 1
    while columns <= 4:
        rows = (len(players) + columns - 1) // columns
        total_height = selection_height * rows + padding * (rows - 1)
        if total_height <= max_height or columns == 4:
            break
        columns += 1

    button_width = (minimap_rect.width - padding * (columns - 1)) // columns
    rows = (len(players) + columns - 1) // columns
    total_height = selection_height * rows + padding * (rows - 1)

    surface = pygame.Surface((minimap_rect.width, total_height), pygame.SRCALPHA)
    font_sel = pygame.font.Font(None, 24)

    for index, player in enumerate(reversed(players)):
        col = index % columns
        row = index // columns
        rect_x = col * (button_width + padding)
        rect_y = row * (selection_height + padding)
        rect = pygame.Rect(rect_x, rect_y, button_width, selection_height)

        if player == selected_player:
            color = (255, 255, 255)
        else:
            color = team_colors[player.teamID % len(team_colors)]

        pygame.draw.rect(surface, color, rect)
        player_text = font_sel.render(f'Player {player.teamID}', True, (0, 0, 0))
        text_rect = player_text.get_rect(center=rect.center)
        surface.blit(player_text, text_rect)

    return surface

def create_player_info_surface(selected_player, screen_width, team_colors):
    font_info = pygame.font.Font(None, 24)
    padding = 5
    info_height = 200
    surface = pygame.Surface((screen_width, info_height), pygame.SRCALPHA)

    team_color = team_colors[selected_player.teamID % len(team_colors)]
    player_name_surface = font_info.render(f"Player {selected_player.teamID}", True, team_color)
    surface.blit(player_name_surface, (padding, 0))

    resources_text = (f"Resources - Food: {selected_player.resources.food}, "
                      f"Wood: {selected_player.resources.wood}, "
                      f"Gold: {selected_player.resources.gold}")
    resources_surface = font.render(resources_text, True, (255, 255, 255))
    surface.blit(resources_surface, (padding, 30))

    unit_counts = Counter(unit.acronym for unit in selected_player.units)
    units_text = "Units - " + ", ".join([f"{acronym}: {count}" for acronym, count in unit_counts.items()])
    units_surface = font_info.render(units_text, True, (255, 255, 255))
    surface.blit(units_surface, (padding, 60))

    building_counts = Counter(building.acronym for building in selected_player.buildings)
    buildings_text = "Buildings - " + ", ".join([f"{acronym}: {count}" for acronym, count in building_counts.items()])
    buildings_surface = font_info.render(buildings_text, True, (255, 255, 255))
    surface.blit(buildings_surface, (padding, 90))

    maximum_population_text = (f"Maximum population : {selected_player.maximum_population}")
    maximum_population = font_info.render(maximum_population_text, True, (255, 255, 255))
    surface.blit(maximum_population, (padding, 120))

    population_text = (f"population : {selected_player.population}")
    population = font.render(population_text, True, (255, 255, 255))
    surface.blit(population, (padding, 150))

    return surface

def draw_game_over_overlay(screen, game_state):
    overlay = pygame.Surface((screen.get_width(), screen.get_height()), pygame.SRCALPHA)
    overlay.fill((50, 50, 50, 150))
    font_big = pygame.font.SysFont(None, 60)
    font_small = pygame.font.SysFont(None, 40)

    winner_id = game_state.get('winner_id', '?')
    text_surf = font_big.render(f"Bravo ! Joueur {winner_id} a gagné", True, (255, 255, 255))
    text_rect = text_surf.get_rect(center=(screen.get_width()//2, screen.get_height()//3))
    overlay.blit(text_surf, text_rect)

    button_text = "Quitter le jeu"
    button_surf = font_small.render(button_text, True, (255, 255, 255))
    button_width = button_surf.get_width() + 20
    button_height = button_surf.get_height() + 10
    button_x = (screen.get_width() - button_width) // 2
    button_y = screen.get_height() // 2
    button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
    pygame.draw.rect(overlay, (100, 100, 100), button_rect)
    overlay.blit(button_surf, button_surf.get_rect(center=button_rect.center))

    game_state['game_over_button_rect'] = button_rect
    screen.blit(overlay, (0, 0))


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\init_assets.py
import re
import pygame
import os
import time
from collections import OrderedDict
from Settings.setup import *

sprites = {}
zoom_cache = {}
MAX_ZOOM_CACHE_PER_SPRITE = 60

gui_elements = {}
gui_cache = {}

ASSETS_LOADED = False

def load_sprite(filepath=None, scale=None, adjust=None):
    if filepath:
        sprite = pygame.image.load(filepath).convert_alpha()
    if scale:
        sprite = pygame.transform.smoothscale(sprite, (int(scale[0]), int(scale[1])))
    if adjust:
        sprite = pygame.transform.smoothscale(sprite, (
            int(sprite.get_width() * adjust),
            int(sprite.get_height() * adjust)
        ))
    sprite = sprite.convert_alpha()
    return sprite

def extract_Unitframes(sheet, rows, columns, frames_entity, scale=TILE_SIZE / 400):
    frames = []
    sheet_width, sheet_height = sheet.get_size()
    frame_width = sheet_width // columns
    frame_height = sheet_height // rows
    target_width = int(frame_width * scale)
    target_height = int(frame_height * scale)

    frame_step = columns // frames_entity
    for row in range(rows):
        if row % 2 != 0:
            continue
        for col in range(columns):
            if col % frame_step == 0:
                x = col * frame_width
                y = row * frame_height
                frame = sheet.subsurface(pygame.Rect(x, y, frame_width, frame_height))
                frame = pygame.transform.smoothscale(frame, (target_width, target_height))
                frames.append(frame)
    return frames

def extract_Buildingframes(sheet, rows, columns, frames_entity, scale=TILE_SIZE / 400):
    frames = []
    sheet_width, sheet_height = sheet.get_size()
    frame_width = sheet_width // columns
    frame_height = sheet_height // rows
    target_width = int(frame_width * scale)
    target_height = int(frame_height * scale)

    frame_step = columns*rows // frames_entity
    print(f'step {frame_step}, cols : {columns}, frames_entity : {frames_entity}')
    for row in range(rows):
        for col in range(columns):
            index = row * columns + col
            if index % frame_step == 0:
                x = col * frame_width
                y = row * frame_height
                frame = sheet.subsurface(pygame.Rect(x, y, frame_width, frame_height))
                frame = pygame.transform.smoothscale(frame, (target_width, target_height))
                frames.append(frame)
    return frames

def draw_progress_bar(screen, progress, screen_width, screen_height, progress_text, loading_screen_image):
    screen.blit(loading_screen_image, (screen_width//2 - loading_screen_image.get_width()//2, screen_height//2 - loading_screen_image.get_height()//2))

    bar_width = screen_width * PROGRESS_BAR_WIDTH_RATIO
    bar_x = (screen_width - bar_width) / 2
    bar_y = screen_height * PROGRESS_BAR_Y_RATIO

    pygame.draw.rect(screen, WHITE, (bar_x, bar_y, bar_width, BAR_HEIGHT), 2, border_radius=BAR_BORDER_RADIUS)
    pygame.draw.rect(screen, WHITE, (bar_x, bar_y, bar_width * progress, BAR_HEIGHT), border_radius=BAR_BORDER_RADIUS)

    text_color = BLACK if progress >= 0.5 else WHITE

    font = pygame.font.Font(None, 36)
    percentage_text = font.render(f"{int(progress * 100)}%", True, text_color)
    if int(progress * 100) == 96:
        time.sleep(2)
    percentage_text_rect = percentage_text.get_rect(center=(bar_x + bar_width / 2, bar_y + BAR_HEIGHT / 2))
    screen.blit(percentage_text, percentage_text_rect)

    progress_text_surface = font.render("Loading " + progress_text, True, WHITE)
    progress_text_rect = progress_text_surface.get_rect(centerx=(bar_x + bar_width / 2), top=(bar_y + BAR_HEIGHT))
    screen.blit(progress_text_surface, progress_text_rect)

    pygame.display.flip()  

def load_sprites(screen, screen_width, screen_height):
    global ASSETS_LOADED
    if ASSETS_LOADED:
        return
    ASSETS_LOADED = True

    global gui_elements
    gui_elements.clear()
    
    total_files = sum(len(files) for _, _, files in os.walk('assets'))
    loaded_files = 0
    
    # Load GUI assets
    for gui_key, gui_val in gui_config.items():
        directory = gui_val.get('directory')
        gui_scale = gui_val.get('scale')
        gui_adjust_scale = gui_val.get('adjust_scale')
        if not directory:
            continue
        gui_elements[gui_key] = []
        try:
            dir_content = os.listdir(directory)
        except FileNotFoundError:
            print(f"Directory not found: {directory}")
            continue

        for filename in dir_content:
            if filename.lower().endswith("webp"):
                filepath = os.path.join(directory, filename)
                loaded_sprite = load_sprite(filepath, gui_scale, gui_adjust_scale)
                gui_elements[gui_key].append(loaded_sprite)
                if gui_key == 'loading_screen':
                    loading_screen = get_scaled_gui('loading_screen', variant=0, target_height=screen_height) 
                    pygame.display.flip()
                    continue
                loaded_files += 1
                progress = loaded_files / total_files
                draw_progress_bar(screen, progress, screen_width, screen_height, gui_key, loading_screen)

    # Load sprites from sprite_config
    for category in sprite_config:
        sprites[category] = {}
        for sprite_name, value in sprite_config[category].items():
            directory = value['directory']
            scale = value.get('scale')
            adjust = value.get('adjust_scale')
            if 'sheet_config' in value:
                sheet_cols = value['sheet_config'].get('columns', 0)
                sheet_rows = value['sheet_config'].get('rows', 0)

            if category in ['resources']:
                sprites[category][sprite_name] = []
                try:
                    dir_content = os.listdir(directory)
                except FileNotFoundError:
                    print(f"Directory not found: {directory}")
                    continue
                for filename in dir_content:
                    if filename.lower().endswith("webp"):
                        filepath = os.path.join(directory, filename)
                        sprite = load_sprite(filepath, scale, adjust)
                        sprites[category][sprite_name].append(sprite)
                        loaded_files += 1
                        progress = loaded_files / total_files
                        # Re-blit loading screen last loaded for continuity
                        draw_progress_bar(screen, progress, screen_width, screen_height, sprite_name,loading_screen)

            elif category == 'buildings':
                sprites[category][sprite_name] = {}
                sprite_path = directory
                if os.path.isdir(sprite_path):
                    state_dirs = os.listdir(sprite_path)
                    for state_dir in state_dirs:
                        state_path = os.path.join(sprite_path, state_dir)
                        if not os.path.isdir(state_path):
                            continue
                        sprites[category][sprite_name].setdefault(state_dir, {})
                        sheets = os.listdir(state_path)
                        for sheetname in sheets:
                            if sheetname.lower().endswith("webp"):
                                filepath = os.path.join(state_path, sheetname)
                                try:
                                    sprite_sheet = load_sprite(filepath, scale, adjust)
                                    if state_dir == 'death':
                                        frames = extract_Buildingframes(sprite_sheet, sheet_rows, sheet_cols, FRAMES_PER_BUILDING)
                                    else:
                                        frames = extract_Buildingframes(sprite_sheet, 1, 1, 1)
                                    print(f"{len(frames)} frames for {sprite_name} in {state_dir} state ")
                                    sprites[category][sprite_name][state_dir] = frames
                                
                                except Exception as e:
                                    print(f"Error loading sprite sheet {filepath}: {e}")
                                loaded_files += 1
                                progress = loaded_files / total_files
                                draw_progress_bar(screen, progress, screen_width, screen_height, sprite_name, loading_screen)
                
            elif category == 'units':
                sprites[category][sprite_name] = {}
                sprite_path = directory
                if os.path.isdir(sprite_path):
                    state_dirs = os.listdir(sprite_path)
                    for state_dir in state_dirs:
                        state_path = os.path.join(sprite_path, state_dir)
                        if not os.path.isdir(state_path):
                            continue
                        sprites[category][sprite_name].setdefault(state_dir, {})
                        sheets = os.listdir(state_path)
                        for sheetname in sheets:
                            if sheetname.lower().endswith("webp"):
                                filepath = os.path.join(state_path, sheetname)
                                try:
                                    sprite_sheet = load_sprite(filepath, scale, adjust)
                                    frames = extract_Unitframes(sprite_sheet, sheet_rows, sheet_cols, FRAMES_PER_UNIT)
                                    print(f"{len(frames)} frames for {sprite_name} in {state_dir} state with {len(frames) // FRAMES_PER_UNIT} directions")
                                    for direction_index in range(len(frames) // FRAMES_PER_UNIT):
                                        direction_frames = frames[direction_index * FRAMES_PER_UNIT : (direction_index + 1) * FRAMES_PER_UNIT]
                                        sprites[category][sprite_name][state_dir][direction_index] = direction_frames
                                except Exception as e:
                                    print(f"Error loading sprite sheet {filepath}: {e}")
                                loaded_files += 1
                                progress = loaded_files / total_files
                                draw_progress_bar(screen, progress, screen_width, screen_height, sprite_name, loading_screen)


                    progress = loaded_files / total_files
                    draw_progress_bar(screen, progress, screen_width, screen_height, sprite_name, loading_screen)

    print("Sprites loaded successfully.")
    
def get_scaled_sprite(name, category, zoom=1.0, state='idle', direction=0, frame=0, variant=0):
    if name not in zoom_cache:
        zoom_cache[name] = OrderedDict()
    cache_key = (zoom, state, frame, variant, direction)
    if cache_key in zoom_cache[name]:
        zoom_cache[name].move_to_end(cache_key)
        return zoom_cache[name][cache_key]

    if not state or state not in sprites[category][name]:
        state = 'idle'

    frame_id = frame  # Define frame_id here

    if category == 'buildings':
        frame_id = frame_id % len(sprites[category][name][state])
        original_image = sprites[category][name][state][frame_id]
    elif category == 'units':
        frame_id = frame_id % len(sprites[category][name][state][direction])
        original_image = sprites[category][name][state][direction][frame_id]
    else: 
        original_image = sprites[category][name][variant]

    scaled_width = int(original_image.get_width() * zoom)
    scaled_height= int(original_image.get_height()* zoom)

    if scaled_width <1: scaled_width=1
    if scaled_height<1: scaled_height=1

    scaled_image = pygame.transform.smoothscale(original_image, (scaled_width, scaled_height))

    zoom_cache[name][cache_key] = scaled_image
    zoom_cache[name].move_to_end(cache_key)
    if len(zoom_cache[name]) > MAX_ZOOM_CACHE_PER_SPRITE:
        zoom_cache[name].popitem(last=False)
    return scaled_image

def get_scaled_gui(ui_name, variant=0, target_width=None, target_height=None):
    global gui_cache
    key = (ui_name, variant, target_width, target_height)
    if key in gui_cache:
        return gui_cache[key]

    original = gui_elements[ui_name][variant]
    ow, oh = original.get_width(), original.get_height()

    if target_width and not target_height:
        ratio = target_width / ow
        target_height = int(oh * ratio)
    elif target_height and not target_width:
        ratio = target_height / oh
        target_width = int(ow * ratio)
    elif not target_width and not target_height:
        gui_cache[key] = original
        return original  # Add this return statement for consistency

    scaled = pygame.transform.smoothscale(original, (target_width, target_height))
    gui_cache[key] = scaled
    return scaled

def fill_grass(screen, screen_x, screen_y, camera):
    from Controller.drawing import draw_sprite
    draw_sprite(screen, ' ', 'resources', screen_x, screen_y, camera.zoom)

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\init_map.py
import sys
import pygame
from Models.Map import GameMap
from Models.Team import Team
from Settings.setup import WINDOW_WIDTH, WINDOW_HEIGHT
from Controller.game_loop import game_loop
from Controller.init_player import init_players

def init_pygame():
    pygame.init()
    pygame.display.set_caption("Age of Empires II - Version Python")

    # Fenêtre directement maximisée.
    screen = pygame.display.set_mode((0, 0), pygame.RESIZABLE | pygame.WINDOWMAXIMIZED)
    screen_width, screen_height = screen.get_width(), screen.get_height()

    pygame.event.post(
        pygame.event.Event(
            pygame.VIDEORESIZE,
            {
                "size": (screen_width, screen_height),
                "w": screen_width,
                "h": screen_height
            }
        )
    )

    return screen, screen_width, screen_height


if __name__ == "__main__":
    grid_size = int(input("Veuillez entrer la taille de la grille : "))
    number_of_players = int(input("Veuillez entrer le nombre de joueurs : "))
    gold_at_center_input = input("Voulez-vous de l'or au centre ? (oui/non) : ").lower()
    gold_at_center = gold_at_center_input == 'oui'

    screen, screen_width, screen_height = init_pygame()
    game_map = GameMap(grid_size, gold_at_center)
    players = init_players(number_of_players)
    game_loop(screen, game_map, screen_width, screen_height, players)


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\init_player.py
from Models.Team import Team

def init_players(number_of_players, difficulty):
    players = []
    for playerId in range(number_of_players):
        team = Team(difficulty, playerId)
        players.append(team)
    return players


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\terminal_display.py
import curses
import time
import os

from Controller.terminal_display_debug import debug_print_set_window, debug_print
from Models.Map import GameMap  # si besoin
from Settings.setup import user_choices
from Models.html import write_full_html


def stop_curses():
    curses.endwin()

def start_terminal_interface(game_map):
    """
    Lance le mode curses en parallèle, pour afficher la carte ASCII + zone debug.
    """
    curses.wrapper(_curses_main, game_map)


def _curses_main(stdscr, game_map):
    """
    Fonction principale curses, gère l'affichage ASCII + lecture clavier 
    pour scroller sur la map, etc.
    """
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.keypad(True)

    # On divise l'écran en 2 : zone map + zone debug
    total_h, total_w = stdscr.getmaxyx()
    debug_h = 5
    map_h = total_h - debug_h

    # Sous-fenêtres
    win_map = curses.newwin(map_h, total_w, 0, 0)
    win_debug = curses.newwin(debug_h, total_w, map_h, 0)
    win_debug.scrollok(True)

    # "Injection" de la fenêtre de debug dans terminal_display_debug.py
    debug_print_set_window(win_debug)

    # On centre la vue curses au départ
    half_map_w = game_map.num_tiles_x // 2
    half_map_h = game_map.num_tiles_y // 2
    game_map.terminal_view_x = max(0, half_map_w - 40)
    game_map.terminal_view_y = max(0, half_map_h - 15)

    def draw_map_portion():
        """
        Dessine la portion visible de la map ASCII dans la fenêtre curses 'win_map'.
        """
        height, width = win_map.getmaxyx()

        # Calcul des "limites" de défilement
        max_view_x = max(0, game_map.num_tiles_x - width)
        max_view_y = max(0, game_map.num_tiles_y - height)

        tvx = max(0, min(game_map.terminal_view_x, max_view_x))
        tvy = max(0, min(game_map.terminal_view_y, max_view_y))
        game_map.terminal_view_x = tvx
        game_map.terminal_view_y = tvy

        for row in range(height):
            map_y = tvy + row
            if map_y < 0 or map_y >= game_map.num_tiles_y:
                # efface la ligne
                try:
                    win_map.move(row, 0)
                    win_map.clrtoeol()
                except curses.error:
                    pass
                continue

            line_chars = []
            for col in range(width):
                map_x = tvx + col
                if map_x < 0 or map_x >= game_map.num_tiles_x:
                    line_chars.append(' ')
                else:
                    entities = game_map.grid.get((map_x, map_y), None)
                    if entities:
                        # On prend la première entité pour l'affichage ASCII
                        e = next(iter(entities))
                        line_chars.append(e.acronym)
                    else:
                        line_chars.append(' ')

            line_str = "".join(line_chars)
            if len(line_str) > width:
                line_str = line_str[:width]

            try:
                win_map.addstr(row, 0, line_str)
            except curses.error:
                pass

        win_map.refresh()

    debug_print("=== Mode curses démarré ===")
    debug_print(f"Map size: {game_map.num_tiles_x} x {game_map.num_tiles_y}")
    debug_print("Tapez ESC pour fermer curses.")

    running = True
    while running:
        try:
            key = stdscr.getch()
        except:
            key = -1

        # -- Fin de partie ? --
        if game_map.game_state and game_map.game_state.get('game_over', False):
            # On affiche un message global
            debug_print("=== GAME OVER ===")
            debug_print("[M] Menu principal | [Q] Quitter")

            # Ici on attend un choix bloquant => on enlève le nodelay
            stdscr.nodelay(False)
            chosen = None
            while chosen is None:
                c = stdscr.getch()
                if c in [ord('m'), ord('M')]:
                    user_choices["menu_result"] = "main_menu"
                    chosen = 'm'
                elif c in [ord('q'), ord('Q')]:
                    user_choices["menu_result"] = "quit"
                    chosen = 'q'
                time.sleep(0.05)
            # On referme curses
            running = False
            break

        if key != -1:
            # ESC => fermer curses
            if key in [27]:  # 27 = ESC
                running = False
                debug_print("Fermeture curses demandée (ESC).")
                break

            move_amount = 1

            if key in [ord('Z'), ord('S'), ord('Q'), ord('D')]:
                move_amount = 2

            if key == curses.KEY_UP or key == ord('z') or key == ord('Z'):
                game_map.terminal_view_y -= move_amount
            elif key == curses.KEY_DOWN or key == ord('s') or key == ord('S'):
                game_map.terminal_view_y += move_amount
            elif key == curses.KEY_LEFT or key == ord('q') or key == ord('Q'):
                game_map.terminal_view_x -= move_amount
            elif key == curses.KEY_RIGHT or key == ord('d') or key == ord('D'):
                game_map.terminal_view_x += move_amount

            elif key == ord('m'):
                debug_print("[CURSES] touche 'm' => recentrer la vue curses")
                half_w = game_map.num_tiles_x // 2
                half_h = game_map.num_tiles_y // 2
                game_map.terminal_view_x = max(0, half_w - 40)
                game_map.terminal_view_y = max(0, half_h - 15)

            # 5) Touche Tab => pause/unpause + snapshot
            elif key == 9:  # ASCII 9 = TAB
                if game_map.game_state is not None:
                    is_paused = not game_map.game_state.get('paused', False)
                    game_map.game_state['paused'] = is_paused
                    if is_paused:
                        if hasattr(game_map, 'players'):
                            write_full_html(game_map.players, game_map)
                        debug_print("[CURSES] Tab => Pause ON + snapshot générée")
                    else:
                        debug_print("[CURSES] Tab => Unpause => reprise du jeu")

            elif key == ord('p'):
                if game_map.game_state is not None:
                    is_paused = not game_map.game_state.get('paused', False)
                    game_map.game_state['paused'] = is_paused
                    if is_paused:
                        debug_print("[CURSES] 'p' => Pause ON")
                    else:
                        debug_print("[CURSES] 'p' => Unpause => reprise du jeu")

            # 6) Touche F11 => Sauvegarde
            elif key == curses.KEY_F11:
                debug_print("[CURSES] F11 => Sauvegarde en cours...")
                game_map.save_map()
                debug_print("[CURSES] => Sauvegarde effectuée !")

            # 7) Touche F12 => Chargement
            elif key == curses.KEY_F12:
                debug_print("[CURSES] F12 => Chargement. (Pour simplifier, on charge la dernière save.)")
                last_save = os.path.join('saves', 'last_save.pkl')
                if os.path.exists(last_save):
                    try:
                        game_map.load_map(last_save)
                        debug_print("[CURSES] => Chargement réussi depuis last_save.pkl.")
                    except Exception as e:
                        debug_print(f"[CURSES] Erreur load: {e}")
                else:
                    debug_print("[CURSES] => Aucune last_save.pkl trouvée.")

        # Redraw
        win_map.erase()
        draw_map_portion()

        if game_map.game_state is not None:
            if not game_map.game_state.get('paused', False):
                game_map.patch(0.01)
        else:
            game_map.patch(0.01)

        time.sleep(0.01)

    debug_print("=== Fin mode curses ===")


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\terminal_display_debug.py
# Chemin : /home/cyril/Documents/Projet_python/Controller/terminal_display_debug.py

import curses

_debug_window = None

def debug_print_set_window(win):
    """
    Permet à 'terminal_display.py' de nous transmettre la window curses
    utilisée pour afficher les messages de debug.
    """
    global _debug_window
    _debug_window = win

def debug_print(msg):
    """
    Méthode globale pour que d'autres modules puissent afficher
    des messages de debug dans la zone debug curses.
    """
    global _debug_window
    if _debug_window is None:
        # Si pas encore initialisé => on ne fait rien
        return

    # On scrolle d'une ligne
    _debug_window.scroll(1)
    # On tronque si trop long
    max_y, max_x = _debug_window.getmaxyx()
    msg = msg[:max_x-1]

    try:
        _debug_window.addstr(max_y - 1, 0, msg)
    except curses.error:
        pass

    _debug_window.refresh()


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\update.py
import pygame
from Models.html import write_full_html

def update_game_state(game_state, delta_time):
    camera = game_state['camera']
    players = game_state['players']
    game_map = game_state['game_map']

    if not game_state.get('paused', False):
        handle_camera(camera, delta_time)

        game_map.patch(delta_time)

        for player in players:
            for building in player.buildings:
                if building.spawnsUnits:
                    building.update_training(delta_time, game_map, player)

def handle_camera(camera, delta_time):
    keys = pygame.key.get_pressed()
    move_speed = 300 * delta_time
    if keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]:
        move_speed *= 2.5

    dx, dy = 0, 0
    if keys[pygame.K_q] or keys[pygame.K_LEFT]:
        dx += move_speed
    if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
        dx -= move_speed
    if keys[pygame.K_z] or keys[pygame.K_UP]:
        dy += move_speed
    if keys[pygame.K_s] or keys[pygame.K_DOWN]:
        dy -= move_speed

    if dx != 0 or dy != 0:
        camera.move(dx, dy)


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Controller\utils.py
import pygame
import math
import colorsys
from Settings.setup import *
import pygame


def to_isometric(x, y, tile_width, tile_height):
    iso_x = (x - y) * (tile_width / 2)
    iso_y = (x + y) * (tile_height / 2)
    return iso_x, iso_y

def screen_to_2_5d(sx, sy, screen_width, screen_height, camera, tile_width, tile_height):
    iso_x = (sx - screen_width / 2) / camera.zoom - camera.offset_x
    iso_y = (sy - screen_height / 2) / camera.zoom - camera.offset_y
    x = ((2 * iso_x) / tile_width + (2 * iso_y) / tile_height) / 2
    y = ((2 * iso_y) / tile_height - (2 * iso_x) / tile_width) / 2
    return x, y
    
def screen_to_tile(sx, sy, screen_width, screen_height, camera, a, b):
    iso_x = (sx - screen_width / 2) / camera.zoom - camera.offset_x
    iso_y = (sy - screen_height / 2) / camera.zoom - camera.offset_y
    x = ((iso_x / a) + (iso_y / b)) / 2
    y = ((iso_y / b) - (iso_x / a)) / 2
    return round(x), round(y)

def tile_to_screen(x, y, width, height, camera, screen_width, screen_height):
    iso_x = (x - y) * (width / 2)
    iso_y = (x + y) * (height / 2)
    screen_x = (iso_x + camera.offset_x) * camera.zoom + screen_width / 2
    screen_y = (iso_y + camera.offset_y) * camera.zoom + screen_height / 2
    return screen_x, screen_y

def get_angle(start, end):
    dx = end[0] - start[0]
    dy = end[1] - start[1]
    angle = math.degrees(math.atan2(dy, dx))
    return (angle + 360) % 360

def get_snapped_angle(start, end, ALLOWED_ANGLES=ALLOWED_ANGLES):
    dx = end[0] - start[0]
    dy = end[1] - start[1]
    angle = math.degrees(math.atan2(dy, dx))
    angle = (angle + 360) % 360
    return min(ALLOWED_ANGLES, key=lambda x: abs(x - angle))

def get_direction(snapped_angle_rad):
    return ((snapped_angle_rad // 45) + 1) % 8

def normalize(v):
    magnitude = math.sqrt(sum(x**2 for x in v))
    return [x / magnitude for x in v] if magnitude else None

def get_centered_rect_in_bottom_right(width, height, screen_width, screen_height, margin=10):
    rect = pygame.Rect(0, 0, width, height)
    center_x = screen_width - margin - (width // 2)
    center_y = screen_height - margin - (height // 2)
    rect.center = (center_x, center_y)
    return rect

def get_color_for_terrain(terrain_type):
    if terrain_type == 'gold':
        return (255, 215, 0)

def generate_team_colors(num_players):
    color_list = []
    step = 1.0 / num_players
    for i in range(num_players):
        hue = (i * step) % 1.0
        if 0.25 <= hue <= 0.4167:
            hue = (hue + 0.2) % 1.0
        r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 0.7)
        color_list.append((int(r * 255), int(g * 255), int(b * 255)))
    return color_list

def compute_map_bounds(game_map):
    tile_width = HALF_TILE_SIZE
    tile_height = HALF_TILE_SIZE / 2
    map_width = game_map.num_tiles_x
    map_height = game_map.num_tiles_y

    corners = [
        (0, 0),
        (0, map_height - 1),
        (map_width - 1, map_height - 1),
        (map_width - 1, 0)
    ]
    iso_coords = [
        to_isometric(x, y, tile_width, tile_height) 
        for (x, y) in corners
    ]

    min_iso_x = min(c[0] for c in iso_coords) - MAP_PADDING
    max_iso_x = max(c[0] for c in iso_coords) + MAP_PADDING
    min_iso_y = min(c[1] for c in iso_coords) - MAP_PADDING
    max_iso_y = max(c[1] for c in iso_coords) + MAP_PADDING

    return min_iso_x, max_iso_x, min_iso_y, max_iso_y

def get_entity_bar_color(entity, game_state, team_colors):
    if entity.team is None:
        return (50, 255, 50)
    return team_colors[entity.team % len(team_colors)]

def generate_team_colors(num_players):
    color_list = []
    step = 1.0 / num_players
    for i in range(num_players):
        hue = (i * step) % 1.0
        if 0.25 <= hue <= 0.4167:
            hue = (hue + 0.2) % 1.0
        r, g, b = colorsys.hsv_to_rgb(hue, 1.0, 0.7)
        color_list.append((int(r * 255), int(g * 255), int(b * 255)))
    return color_list

def get_entity_bar_color(entity, game_state, team_colors):
    if entity.team is None:
        return (50, 255, 50)
    return team_colors[entity.team % len(team_colors)]


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Entity.py
import time
import math
from Models.Resources import Resources
from Settings.setup import HALF_TILE_SIZE
from Controller.utils import tile_to_screen
from Controller.drawing import draw_healthBar, draw_hitbox
import pygame

class Entity:
    id = 0
    def __init__(
        self, 
        x, 
        y, 
        team, 
        acronym, 
        size, 
        max_hp, 
        cost=Resources(),
        walkable = False,
        hasResources = False,
        hitbox=0
    ):
        self.x = x
        self.y = y
        self.team = team
        self.acronym = acronym
        self.size = size
        self.max_hp = max_hp
        self.cost = cost
        self.walkable = walkable
        self.hasResources = hasResources
        
        self.hp = max_hp
        self.hitbox = hitbox if hitbox > 0 else size/2
        self.last_damage_time = 0
        self.last_clicked_time = 0

        self.state = 'idle'
        self.current_frame = 0
        self.frame_duration = 0
        self.cooldown_frame = None

        self.death_timer = 0
        self.death_duration = 5

        self.entity_id = Entity.id
        Entity.id += 1

    def isAlive(self):
        if self.hp > 0:
            return True
        return False

    def notify_damage(self):
        self.last_damage_time = time.time()

    def notify_clicked(self):
        self.last_clicked_time = time.time()

    def should_draw_health_bar(self):
        if not hasattr(self, 'hp') or self.hp <= 0 or self.max_hp is None or self.max_hp <= 0:
            return False
        current_time = time.time()
        return ((current_time - self.last_damage_time) < self.HEALTH_BAR_DISPLAY_DURATION) or \
               ((current_time - self.last_clicked_time) < self.HEALTH_BAR_DISPLAY_DURATION)

    def get_health_ratio(self):
        """Returns the ratio between current HP and max HP."""
        if not self.max_hp:
            return 0
        return max(0.0, self.hp / self.max_hp)

    def display_hitbox(self, screen, screen_width, screen_height, camera):
        corner_distance = self.size / 2.0
        corners = [
            (self.x - corner_distance, self.y - corner_distance),
            (self.x - corner_distance, self.y + corner_distance),
            (self.x + corner_distance, self.y + corner_distance),
            (self.x + corner_distance, self.y - corner_distance)
        ]
        
        screen_corners = []
        for corner in corners:
            x_screen, y_screen = tile_to_screen(
                corner[0], 
                corner[1], 
                HALF_TILE_SIZE, 
                HALF_TILE_SIZE / 2, 
                camera, 
                screen_width, 
                screen_height
            )
            screen_corners.append((x_screen, y_screen))
        
        draw_hitbox(screen, screen_corners, camera.zoom)

    def display_range(self, screen, screen_width, screen_height, camera):
        if hasattr(self, 'attack_range') and self.attack_range:
            center = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
            range_iso = self.attack_range / math.cos(math.radians(45))
            width =  range_iso * camera.zoom * HALF_TILE_SIZE 
            height = range_iso * camera.zoom * HALF_TILE_SIZE / 2
            x = center[0] - width // 2
            y = center[1] - height // 2 
            pygame.draw.ellipse(screen, (255, 0, 0), (x, y, width, height), 1)
            #pygame.draw.rect(screen, (0, 255, 0), (x, y, width, height), 1)

    def display_healthbar(self, screen, screen_width, screen_height, camera, color=(0,200,0)):
        """Displays the entity's health bar above its position."""
        if self.hp <= 0 or not self.max_hp:
            return  # do not draw if dead or max_hp is invalid
        
        ratio = self.get_health_ratio()
        if ratio <= 0.0:
            return
        
        # Screen coordinates
        sx, sy = tile_to_screen(
            self.x, 
            self.y, 
            HALF_TILE_SIZE, 
            HALF_TILE_SIZE / 2, 
            camera, 
            screen_width, 
            screen_height
        )

        draw_healthBar(screen, sx, sy, ratio, color)

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\ArcheryRange.py
from Entity.Building import Building
from Models.Resources import Resources
from Entity.Unit import Archer

class ArcheryRange(Building):
    def __init__(self, x=0, y=0, team=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='A',
            size=3,
            max_hp=500,
            cost=Resources(food=0, gold=0, wood=175),
            buildTime=50,
            spawnsUnits=True
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Barracks.py
from Entity.Building import Building
from Entity.Unit.Swordsman import Swordsman
from Models.Resources import Resources

class Barracks(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='B',
            size=3,
            max_hp=600,
            cost=Resources(food=0, gold=0, wood=175),
            buildTime=60,
            spawnsUnits=True
        )

    def build_time(self, num_villagers):
        return (3 * self.build_time) / (num_villagers + 2)

    def train(self, team, clock,map):
        swordsman = Swordsman(team.teamID)
        if(team.resources["food"] >= swordsman.cost.food and team.resources["gold"] >= swordsman.cost.gold and team.maximum_population>len(team.units)):
            team.resources["food"] -= swordsman.cost.food
            team.resources["gold"] -= swordsman.cost.gold
            team.en_cours[swordsman] = clock
        else:
            print("not enough resssources or maximum poulation reached")

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Building.py
from Entity.Entity import Entity
from Controller.utils import tile_to_screen
from Settings.setup import HALF_TILE_SIZE, FRAMES_PER_BUILDING, GAME_SPEED
from Settings.setup import HALF_TILE_SIZE, GAME_SPEED
from Controller.drawing import draw_sprite
from random import randint
from AiUtils.aStar import a_star
from Entity.Unit.Archer import Archer
from Entity.Unit.Swordsman import Swordsman
from Entity.Unit.Horseman import Horseman
from Entity.Unit.Villager import Villager
from Models.Resources import Resources

UNIT_TRAINING_MAP = {
    'T': 'villager',   # TownCentre => Villager
    'A': 'archer',     # ArcheryRange => Archer
    'B': 'swordsman',  # Barracks => Swordsman
    'S': 'horseman'    # Stable => Horseman
}
UNIT_CLASSES = {
    'villager':  Villager,
    'archer':    Archer,
    'swordsman': Swordsman,
    'horseman':  Horseman,
}

class Building(Entity):
    def __init__(
        self, 
        x, 
        y, 
        team, 
        acronym, 
        size, 
        max_hp, 
        cost, 
        buildTime, 
        population = 0, 
        resourceDropPoint = False,
        spawnsUnits = False, 
        walkable = False,
        attack_power = 0, 
        attack_range = 0,
        hasResources = False,
    ):
        super().__init__(
            x=x, 
            y=y, 
            team=team, 
            acronym=acronym, 
            size=size, 
            max_hp=max_hp, 
            cost=cost, 
            walkable=walkable,
            hasResources=hasResources
        )
        self.buildTime = buildTime
        self.population = population
        self.resourceDropPoint = resourceDropPoint
        self.spawnsUnits = spawnsUnits
        self.attack_power = attack_power
        self.attack_range = attack_range
        self.constructors = []

        self.frames = FRAMES_PER_BUILDING

        self.training_queue = []
        self.current_training_unit = None
        self.current_training_time_left = 0
        self.training_progress = 0.0
        self.removed = False

    # ---------------- Update Unit ---------------
    def update(self, game_map, dt):
        self.animator(dt)
        if self.isAlive():
            if self.spawnsUnits:
                self.update_training(dt, game_map, self.team)
        else:
            self.death(game_map)

    # ---------------- Controller ----------------
    def kill(self):
        self.state = 'death'
        self.current_frame = 0
        self.hp = 0

    def death(self, game_map):
        if self.state != 'death' :
            self.kill()

        if self.current_frame == self.frames - 1 and self.state == 'death':
            self.state = ''

        if self.state == 7 and not self.removed:
            self.removed = True
            for player in game_map.game_state['players']:
                if hasattr(player, 'buildings') and self in player.buildings:
                    player.buildings.remove(self)
                    break
            game_map.remove_entity(self)
            game_map.game_state['player_info_updated'] = True
    
    # ---------------- Display Logic ----------------
    def animator(self, dt):
        if self.state:
            if self.state != 'idle':
                self.frame_duration += dt
                frame_time = 1.0 / self.frames
                if self.frame_duration >= frame_time:
                    self.frame_duration -= frame_time
                    self.current_frame = (self.current_frame + 1) % self.frames

            if self.cooldown_frame:
                self.current_frame = self.cooldown_frame

    def display(self, screen, screen_width, screen_height, camera, dt):
        sx, sy = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        draw_sprite(screen, self.acronym, 'buildings', sx, sy, camera.zoom, state=self.state, frame=self.current_frame)

    def is_walkable(self):
        return self.walkable

    def add_to_training_queue(self, team):
        """
        Attempt to enqueue a new unit if enough resources. 
        Return True if successful, False otherwise.
        """
        if self.acronym not in UNIT_TRAINING_MAP:
            return False

        unit_name = UNIT_TRAINING_MAP[self.acronym]
        unit_class = UNIT_CLASSES[unit_name]
        unit = unit_class(team=self.team)


        if (team.resources.has_enough(unit.cost.get()) and team.population < team.maximum_population ):
            team.resources.decrease_resources(unit.cost.get())
            self.training_queue.append(unit_name)
            return True

        return False

    def update_training(self, delta_time, game_map, team):
        """
        Updates the building's training queue each frame.
        """
        if not self.training_queue and not self.current_training_unit:
            return

        if not self.current_training_unit:
            next_unit_name = self.training_queue.pop(0)
            unit_class = UNIT_CLASSES[next_unit_name]
            unit = unit_class(team=self.team)
            self.current_training_unit = next_unit_name
            self.current_training_time_left = unit.training_time / GAME_SPEED
            self.training_progress = 0.0

        if self.current_training_unit:
            self.current_training_time_left -= delta_time
            unit_class = UNIT_CLASSES[self.current_training_unit]
            total_time = unit_class(team=self.team).training_time / GAME_SPEED
            self.training_progress = max(0.0, min(1.0, 1.0 - (self.current_training_time_left / total_time)))

            if self.current_training_time_left <= 0:
                self.spawn_trained_unit(self.current_training_unit, game_map, team)
                self.current_training_unit = None
                self.current_training_time_left = 0
                self.training_progress = 0.0

    def spawn_trained_unit(self, unit_name, game_map, team):
        """
        Once the unit is fully trained, find a free adjacent tile, place the unit, 
        and make it move randomly away from the building.
        """
        unit_class = UNIT_CLASSES[unit_name]
        spawn_tile = self.find_adjacent_tile(game_map)
        if not spawn_tile:
            return

        new_unit = unit_class(team=self.team)
        placed_ok = game_map.add_entity(new_unit, spawn_tile[0], spawn_tile[1])
        if not placed_ok:
            return

        game_map.game_state['player_info_updated'] = True
        self.move_unit_randomly(new_unit, game_map)

    def find_adjacent_tile(self, game_map):
        """
        Search tiles around the building in an expanding square to find a walkable one.
        """
        base_x, base_y = round(self.x), round(self.y)
        for radius in range(1, 8):
            for check_x in range(base_x - radius, base_x + radius + 1):
                for check_y in range(base_y - radius, base_y + radius + 1):
                    if (0 <= check_x < game_map.num_tiles_x and 
                        0 <= check_y < game_map.num_tiles_y):
                        if game_map.walkable_position((check_x, check_y)):
                            return (check_x, check_y)
        return None

    def move_unit_randomly(self, new_unit, game_map):
        """
        Move newly spawned unit up to ~5 tiles away randomly, if walkable.
        Makes up to 10 attempts to find a walkable position.
        If no walkable position is found, unit stays near the building.
        """
        origin_x, origin_y = round(new_unit.x), round(new_unit.y)
        max_attempts = 10
        
        for attempt in range(max_attempts):
            offset_x = randint(-5, 5)
            offset_y = randint(-5, 5)
            target_x = origin_x + offset_x
            target_y = origin_y + offset_y
            
            if (0 <= target_x < game_map.num_tiles_x and 
                0 <= target_y < game_map.num_tiles_y and
                game_map.walkable_position((target_x, target_y))):
                # Calculer ET assigner le path à l'unité
                new_unit.set_destination((target_x, target_y), game_map)
                new_unit.destination = (target_x, target_y)
                return

    def stock(self, game_map, resources):
        if self.resourceDropPoint:
            team_resources = game_map.players[self.team].resources
            if team_resources.increase_resources(resources):
                return resources
        return None

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Camp.py
from Entity.Building import Building
from Models.Resources import Resources

class Camp(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='C',
            size=2,
            max_hp=200,
            cost=Resources(food=0, gold=0, wood=100),
            buildTime=25,
            resourceDropPoint=True
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Farm.py
from Entity.Building import Building
from Models.Resources import Resources

class Farm(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='F',
            size=2,
            max_hp=100,
            cost=Resources(food=0, gold=0, wood=60),
            buildTime=10,
            walkable=True
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\House.py
from Entity.Building import Building
from Models.Resources import Resources

class House(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='H',
            size=2,
            max_hp=200,
            cost=Resources(food=0, gold=0, wood=25),
            buildTime=25,
            population=5
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Keep.py
from Entity.Building import Building
from Models.Resources import Resources

class Keep(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='K',
            size=1,
            max_hp=800,
            cost=Resources(food=0, gold=125, wood=35),
            buildTime=80,
            attack_power=5,
            attack_range=8
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\Stable.py
from Entity.Building import Building
from Models.Resources import Resources
from Entity.Unit.Horseman import Horseman

class Stable(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='S',
            size=3,
            max_hp=550,
            cost=Resources(food=0, gold=0, wood=175),
            buildTime=70,
            spawnsUnits=True
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\TownCentre.py
from Entity.Building import Building
from Models.Resources import Resources

class TownCentre(Building):
    def __init__(self, team, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym='T',
            size=4,
            max_hp=1200,
            cost=Resources(food=0, gold=0, wood=200),
            buildTime=100,
            population=5,
            resourceDropPoint=True,
            spawnsUnits=True
        )

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Building\__init__.py
from .Building import Building
from .Camp import Camp
from .Farm import Farm
from .Barracks import Barracks
from .Stable import Stable
from .ArcheryRange import ArcheryRange
from .Keep import Keep
from .TownCentre import TownCentre
from .House import House


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Resource\Gold.py
import random
from Controller.init_assets import sprite_config
from Entity.Resource.Resource import Resource
from Models.Resources import Resources
import math

class Gold(Resource):
    def __init__(self, 
        x, 
        y, 
        acronym = 'G', 
        storage = Resources(food=0, gold=800, wood=0),
        max_hp=800
        ):

        super().__init__(x=x, y=y, acronym=acronym, storage=storage, max_hp=max_hp, variant=random.randint(0, sprite_config['resources']['tree']['variant'] - 1))

    def get_variant(self, total_variants=sprite_config['resources']['gold']['variant']):
        ratio = (self.max_hp - self.hp) / float(self.max_hp)
        self.variant = int(math.floor(ratio * (total_variants - 1)))
        return min(self.variant, total_variants)

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Resource\Resource.py
from Entity.Entity import Entity
from Settings.setup import HALF_TILE_SIZE
from Controller.utils import tile_to_screen
from Controller.drawing import draw_sprite
from copy import copy

class Resource(Entity):
    def __init__(self, x, y, acronym, storage, max_hp, variant=0):
        super().__init__(x = x, y = y,  team = None,  acronym = acronym, size = 1, max_hp = max_hp, hasResources = True)
        
        self.storage = storage.copy()
        self.maximum_storage = storage.copy()
        self.variant = variant

    def update(self, game_map, dt):
        self.animator(dt)
        if not self.isAlive():
            self.kill()

    def kill(self):
        self.current_frame = 0
        self.hp = 0
        self.state = ''

    def animator(self, dt):
        self.variant = self.get_variant()

    def display(self, screen, screen_width, screen_height, camera, dt):
        screen_x, screen_y = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        draw_sprite(screen, self.acronym, 'resources', screen_x, screen_y, camera.zoom, variant=self.variant)

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Resource\Tree.py
from Entity.Resource.Resource import Resource
from Models.Resources import Resources
from Controller.init_assets import sprite_config
import random

class Tree(Resource):
    def __init__(self, 
        x, 
        y, 
        acronym = 'W', 
        storage = Resources(food=0, gold=0, wood=100),
        max_hp=100
        ):

        super().__init__(x=x, y=y, acronym=acronym, storage=storage, max_hp=max_hp, variant=random.randint(0, sprite_config['resources']['tree']['variant'] - 1))

    def get_variant(self):
        return self.variant

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\Archer.py
from Entity.Unit import Unit
from Models.Resources import Resources

class Archer(Unit):
    def __init__(self, team=None, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym="a",
            max_hp=30,
            cost=Resources(food=0, gold=45, wood=25),
            attack_power=4,
            attack_range=4,
            attack_speed=2.03,
            speed=1,
            training_time=35
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\Horseman.py
from Entity.Unit import Unit
from Models.Resources import Resources

class Horseman(Unit):
    def __init__(self, team=None, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym="h",
            max_hp=45,
            cost=Resources(food=80, gold=20, wood=0),
            attack_power=10,
            attack_range=1,
            attack_speed=1.90,
            speed=1.2,
            training_time=30
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\Swordsman.py
from Entity.Unit import Unit
from Models.Resources import Resources

class Swordsman(Unit):
    def __init__(self, team=None, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym="s",
            max_hp=40,
            cost=Resources(food=50, gold=20, wood=0),
            attack_power=4,
            attack_range=1,
            attack_speed=2.03,
            speed=0.9,
            training_time=20
        )


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\Unit.py
import math
import pygame
import random
from AiUtils.aStar import a_star
from Entity.Entity import Entity
from Entity.Building import Building
from Settings.setup import FRAMES_PER_UNIT, HALF_TILE_SIZE,TILE_SIZE, ALLOWED_ANGLES, ATTACK_RANGE_EPSILON, UNIT_HITBOX
from Controller.utils import tile_to_screen, get_direction, get_snapped_angle, normalize
from Controller.drawing import draw_sprite, draw_hitbox, draw_path

class Unit(Entity):
    def __init__(
        self,
        x,
        y,
        team,
        acronym,
        max_hp,
        cost,
        attack_power,
        attack_range,
        attack_speed,
        speed,
        training_time
        ):
        super().__init__(x=x, y=y, team=team, acronym=acronym, size=1, max_hp=max_hp, cost=cost, walkable=True, hitbox=UNIT_HITBOX)
        
        self.attack_power = attack_power
        self.attack_range = attack_range
        self.attack_speed = attack_speed
        self.attack_target = None
        self.attack_timer = 0
        self.follow_timer = 0
        
        self.speed = speed
        self.training_time = training_time
        self.path = []
        self.collision_timer = 0

        self.frames = FRAMES_PER_UNIT
        self.direction = 0
        self.removed = False

    # ---------------- Update Unit ---------------
    def update(self, game_map, dt):
        self.animator(dt)
        if self.isAlive():
            self.setIdle()
            self.seekAttack(game_map, dt)
            self.seekCollision(game_map, dt)
            self.seekMove(game_map, dt)
        else:
            self.death(game_map, dt)

    # ---------------- Controller ----------------
    def setIdle(self):
        if self.state != 'idle':
            self.state = 'idle'
        self.cooldown_frame = None

    def set_target(self, target):
        self.attack_target = None
        self.set_destination(None, None)
        if target and target.team != None and target.isAlive() and target.entity_id != self.entity_id and target.team != self.team:
            self.attack_target = target
            

    def set_destination(self, destination, game_map):
        if destination and game_map:
            self.path = a_star((self.x, self.y), destination, game_map)
        else:
            self.path = []

    def kill(self):
        self.state = 'death'
        self.cooldown_frame = None
        self.attack_target = None
        self.path = []
        self.current_frame = 0
        self.hp = 0
    # ---------------- Move Logic ----------------
    def seekMove(self, game_map, dt, ALLOWED_ANGLES=ALLOWED_ANGLES):
        if self.path:
            self.state = 'walk'

            target_tile = self.path[0]        
            snapped_angle = get_snapped_angle(((self.x, self.y)), (target_tile[0], target_tile[1]))
            self.direction = get_direction(snapped_angle)
            diff = [target_tile[0] - self.x, target_tile[1] - self.y]
            diff = normalize(diff)
            if diff:
                step = [component * dt *  self.speed for component in diff]

            self.x += step[0]
            self.y += step[1]

            dx = target_tile[0] - self.x
            dy = target_tile[1] - self.y
                
            if abs(dx) <= abs(step[0]) and abs(dy) <= abs(step[1]):
                self.path.pop(0)
                old_position = game_map.remove_entity(self)
                if not game_map.add_entity(self, self.x, self.y):
                    game_map.add_entity(self, old_position[0], old_position[1])


            return self.path

    def seekCollision(self, game_map, dt):
        if not self.path:
            rounded_position = (round(self.x), round(self.y))
            entities = game_map.grid.get(rounded_position, None)
            if entities:
                for entity in entities:
                    if entity.entity_id != self.entity_id:
                        distance = math.dist((entity.x, entity.y), (self.x, self.y))
                        hitbox_difference = distance - abs(self.hitbox + entity.hitbox)
                        if hitbox_difference < 0:
                            diff = [self.x - entity.x, self.y - entity.y]
                            diff = normalize(diff)
                            if diff:
                                force = [component * self.hitbox for component in diff]
                                '''
                                if self.path:
                                    perp = [-diff[1], diff[0]]
                                    perp_factor = 0.3
                                    force[0] += perp[0] * perp_factor
                                    force[1] += perp[1] * perp_factor
                                '''
                                new_pos = (self.x + force[0], self.y + force[1])
                                if game_map.walkable_position(new_pos):
                                    self.path.insert(0, new_pos)
            return True

    # ---------------- Attack Logic ----------------
    def seekAttack(self, game_map, dt):
        if self.attack_target and self.attack_target.isAlive():
            distance = math.dist((self.x, self.y), (self.attack_target.x, self.attack_target.y)) - self.attack_target.hitbox - self.attack_range

            if distance <= 0 :
                self.state = 'attack'
                self.direction = get_direction(get_snapped_angle((self.x, self.y), (self.attack_target.x, self.attack_target.y))) 
                if self.attack_timer == 0:
                    self.current_frame = 0
                    self.path = []
                
                elif self.current_frame == self.frames - 1:
                    self.cooldown_frame = self.current_frame
                    
                self.attack_timer += dt
                if self.attack_timer >= self.attack_speed:
                    self.attack_target.hp -= self.attack_power
                    self.attack_timer = 0
                    self.cooldown_frame = None
            else :
                if self.path:
                    self.path = [self.path[0]] + a_star((self.x, self.y), (self.attack_target.x,self.attack_target.y), game_map)
                else:
                    self.set_destination((self.attack_target.x,self.attack_target.y), game_map)

                self.attack_timer = 0
        else: 
            self.attack_target = None

    # ---------------- Death Logic ----------------
    def death(self, game_map, dt):
        if self.death_timer == 0:
            self.kill()
        
        if self.current_frame == self.frames - 1 and self.state == 'death':
            self.cooldown_frame = self.current_frame
        
        if self.death_timer > self.death_duration and self.state == 'death':
            self.state = 'decay'
            self.current_frame = 0
            self.cooldown_frame = None

        if self.state == 'decay' and  self.current_frame == self.frames - 1:
            self.state = ''
        self.death_timer+=dt

    def animator(self, dt):
        if self.state:
            self.frame_duration += dt
            frame_time = 1.0 / self.frames
            if self.frame_duration >= frame_time:
                self.frame_duration -= frame_time
                self.current_frame = (self.current_frame + 1) % self.frames

            if self.cooldown_frame:
                self.current_frame = self.cooldown_frame

    # ---------------- Display Logic ----------------
    def display(self, screen, screen_width, screen_height, camera, dt):
        sx, sy = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        draw_sprite(screen, self.acronym, 'units', sx, sy, camera.zoom, state=self.state, frame=self.current_frame, direction=self.direction)

    def display_hitbox(self, screen, screen_width, screen_height, camera):
        center = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        hitbox_iso = self.hitbox / math.cos(math.radians(45))
        width =  hitbox_iso * camera.zoom * HALF_TILE_SIZE
        height = hitbox_iso * camera.zoom * HALF_TILE_SIZE / 2
        x = center[0] - width // 2
        y = center[1] - height // 2 
        pygame.draw.ellipse(screen, (255, 255, 255), (x, y, width, height), 1)
        #pygame.draw.rect(screen, (0, 0, 255), (x, y, width, height), 1)
    
    def display_path(self, screen, screen_width, screen_height, camera):
        unit_position = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        color = ((self.entity_id * 30) % 255, (self.entity_id*20) % 255, (self.entity_id*2) % 255)
        transformed_path = [unit_position, *[ tile_to_screen(x, y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height) for x, y in self.path ] ]
        draw_path(screen, unit_position, transformed_path, camera.zoom, color)
    
    def display_path(self, screen, screen_width, screen_height, camera):
        unit_position = tile_to_screen(self.x, self.y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height)
        color = ((self.entity_id * 30) % 255, (self.entity_id*20) % 255, (self.entity_id*2) % 255)
        transformed_path = [unit_position, *[ tile_to_screen(x, y, HALF_TILE_SIZE, HALF_TILE_SIZE / 2, camera, screen_width, screen_height) for x, y in self.path ] ]
        draw_path(screen, unit_position, transformed_path, camera.zoom, color)

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\Villager.py
import math
import pygame
from Settings.setup import MAXIMUM_CARRY, RESOURCE_RATE_PER_SEC, Resources, FRAMES_PER_UNIT, HALF_TILE_SIZE,TILE_SIZE, ALLOWED_ANGLES, ATTACK_RANGE_EPSILON, UNIT_HITBOX, villager_tasks
from Entity.Unit.Unit import Unit
from AiUtils.aStar import a_star
from Controller.utils import get_direction, get_snapped_angle
from Controller.terminal_display_debug import debug_print


class Villager(Unit):
    def __init__(self, team=None, x=0, y=0):
        super().__init__(
            x=x,
            y=y,
            team=team,
            acronym="v", 
            max_hp=40, 
            cost=Resources(food=50, gold=0, wood=25), 
            attack_power=2,
            attack_range=1, 
            attack_speed=2.03,
            speed=1, 
            training_time=20, 

        )
        self.carry = Resources(food=0, gold=0, wood=0)
        self.resource_rate = RESOURCE_RATE_PER_SEC
        self.task = None
        self.collect_target = None
        self.build_target = None
        self.stock_target = None
        self.task_timer = 0

    # ---------------- Update Unit ---------------
    def update(self, game_map, dt):
        self.animator(dt)
        if self.isAlive():
            self.setIdle()
            self.seekAttack(game_map, dt)
            self.seekCollision(game_map, dt)
            self.seekCollect(game_map, dt)
            self.seekStock(game_map)
            self.seekMove(game_map, dt)
            #self.seekBuild(game_map, dt)
        else:
            self.death(game_map, dt)

    # ---------------- Controller ----------------
    def set_target(self, target):
        self.attack_target = None
        self.collect_target = None
        self.build_target = None
        self.stock_target = None
        self.set_destination(None, None)

        if target and target.isAlive() and target.entity_id != self.entity_id:
            if target.hasResources:
                self.set_task('collect', target)

            elif target.team == self.team and hasattr(target, 'population'):
                if target.resourceDropPoint and target.state == 'idle':
                    self.set_task('stock', target)
                else:
                    self.set_task('build', target)
            
            elif target.team != self.team:
                self.attack_target = target

    def set_task(self, task, target = None):
        self.attack_target = None
        self.collect_target = None
        self.build_target = None
        self.stock_target = None
        self.task = None
        
        if task in villager_tasks:
            self.task = task
            setattr(self, villager_tasks[task], target)

    def isAvailable(self):
        return not self.task

    def seekCollect(self, game_map, dt):
        if self.task != 'collect':
            return

        if not self.collect_target or not self.collect_target.isAlive():
            self.task = 'stock'
            return

        distance = math.dist((self.x, self.y), (self.collect_target.x, self.collect_target.y)) \
                   - self.collect_target.hitbox - self.attack_range

        # Stop if carrying too much or far away
        if distance > 0 or self.carry.total() >= MAXIMUM_CARRY:
            if not self.path:
                self.set_destination((self.collect_target.x, self.collect_target.y), game_map)
                self.task_timer = 0
            return

        # Collect resources
        self.state = 'task'
        self.direction = get_direction(get_snapped_angle((self.x, self.y),
                                                         (self.collect_target.x, self.collect_target.y)))

        # Initialize partial collect amount
        if self.task_timer == 0:
            self.current_frame = 0
            self.temp_collect_amount = 0
            self.set_destination(None, game_map)

        self.task_timer += dt
        self.temp_collect_amount += min(self.resource_rate * dt, abs(MAXIMUM_CARRY - self.carry.total()))

        # Resource transaction
        if self.temp_collect_amount >= 1:
            collected_whole = round(self.temp_collect_amount)
            resource_collected = self.collect_target.storage.decrease_resources((collected_whole,
                                                                                 collected_whole,
                                                                                 collected_whole))
            self.collect_target.hp -= max(resource_collected)
            self.carry.increase_resources(resource_collected)
            self.temp_collect_amount = 0

        if self.carry.total() >= MAXIMUM_CARRY or not self.collect_target.isAlive():
            self.task = 'stock'

    def seekStock(self, game_map):
        if self.task != 'stock':
            return
        if self.stock_target and self.stock_target.isAlive():
            distance = math.dist((self.x, self.y), (self.stock_target.x, self.stock_target.y)) - self.stock_target.hitbox - self.attack_range
            if self.carry.total() == 0:
                    self.task = 'collect'
                    return
            if distance <= 0:
                self.state = 'idle'
                self.set_destination(None, game_map)
                self.stock_target.stock(game_map, self.carry.get())
                self.carry.reset()
            elif not self.path:
                self.set_destination((self.stock_target.x, self.stock_target.y), game_map)
       
        else :
            closest_building = None
            min_distance = float('inf')
            for building in game_map.players[self.team].buildings:
                if building.resourceDropPoint:
                    distance = math.dist((self.x, self.y),(building.x, building.y))
                    if distance < min_distance:
                        min_distance = distance
                        closest_building = building
            if closest_building:
                self.stock_target = closest_building


    '''
    def collectResource(self, resource_tile, duration, game_map):
        if not self.isAvailable():
            return
        if not isinstance(resource_tile, Resource):
            return
        self.task = 'collect'
        self.move(resource_tile.x, resource_tile.y, game_map)
        collected = min(
            self.resource_rate * duration,
            self.carry_capacity - getattr(self.resources, resource_tile.acronym.lower(), 0)
        )
        setattr(self.resources, resource_tile.acronym.lower(), getattr(self.resources, resource_tile.acronym.lower(), 0) + collected)
        resource_tile.storage = Resources(
            food=resource_tile.storage.food - (collected if resource_tile.acronym == "F" else 0),
            gold=resource_tile.storage.gold - (collected if resource_tile.acronym == "G" else 0),
            wood=resource_tile.storage.wood - (collected if resource_tile.acronym == "W" else 0),
        )
        if resource_tile.storage.food <= 0 and resource_tile.storage.gold <= 0 and resource_tile.storage.wood <= 0:
            game_map.remove_entity(resource_tile, resource_tile.x, resource_tile.y)
        self.task = False

    def stockResources(self, building, game_map, team):
        if not self.isAvailable() or not hasattr(building, 'resourceDropPoint') or not building.resourceDropPoint:
            return
        self.task = 'stock'
        self.move(building.x, building.y, game_map)
        team.resources = Resources(
            food=team.resources.food + self.resources.food,
            gold=team.resources.gold + self.resources.gold,
            wood=team.resources.wood + self.resources.wood,
        )
        self.resources = Resources(food=0, gold=0, wood=0)
        self.task = False

    def build(self, map,building):
        if not self.isAvailable():
            return
        self.task = 'build'
        self.move((building.x, building.y), map)
        building.constructors.append(self)

    
    def buildTime(self, building, num_villagers):
        return max(10, (3 * building.buildTime) / (num_villagers + 2)) if num_villagers > 0 else building.buildTime
    '''

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Entity\Unit\__init__.py
from .Unit import Unit 
from .Villager import Villager  # Importe la classe Villager dans le package
from .Swordsman import Swordsman  # Importe la classe Swordsman dans le package
from .Horseman import Horseman  # Importe la classe Horseman dans le package
from .Archer import Archer  # Importe la classe Archer dans le package

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Models\html.py
import webbrowser
import os
from Entity.Resource.Resource import Resource

def write_full_html(players, game_map):
    template = """
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Snapshot complet du jeu</title>
    </head>
    <body>
        <h1>Snapshot du jeu</h1>
    """

    for team in players:
        template += f"""
        <h2>Joueur {team.teamID}</h2>
        <details>
            <summary>infos générales</summary>
            <p>
                <!-- Exemples : mimic create_player_info_surface -->
                <b>Resources</b>: Food={team.resources.food}, Wood={team.resources.wood}, Gold={team.resources.gold}<br>
                <b>Population</b>: {team.population}/{team.maximum_population}<br>
                <!-- Données supplémentaires -->
                <b>Team Color</b>: <!-- team color placeholder --><br>
                <b>Ennemis tués</b>: <!-- number of enemies killed placeholder --><br>
                <!-- Autres statistiques de combat, exp, etc. -->
            </p>
        </details>

        <details>
            <summary>Unités</summary>
            <ul>
        """
        for unit in team.units:
            template += f"""
            <li>
                <details>
                    <summary>Unité ID: {unit.id} ({unit.acronym})</summary>
                    <p>
                        <b>HP</b>: {unit.hp}/{unit.max_hp}<br>
                        <b>Position</b>: ({unit.x}, {unit.y})<br>
                        <!-- Add any other relevant unit information -->
                    </p>
                </details>
            </li>
            """
        template += """
            </ul>
        </details>

        <details>
            <summary>Bâtiments</summary>
            <ul>
        """
        for building in team.buildings:
            template += f"""
            <li>
                <details>
                    <summary>Bâtiment: {type(building).__name__}</summary>
                    <p>
                        <b>HP</b>: {building.hp}/{building.max_hp}<br>
                        <b>Position</b>: ({building.x}, {building.y})<br>
                        <!-- Add any other relevant building information -->
                    </p>
                </details>
            </li>
            """
        template += """
            </ul>
        </details>
        """

    template += """
        <h2>Ressources sur la carte</h2>
        <details>
            <summary>Ressources</summary>
    """
    # Parcours des ressources dans la grille
    # On considère que game_map.grid contient des ressources
    for pos, entities in game_map.grid.items():
        for entity in entities:
            if isinstance(entity, Resource):
                template += f"""
                <p>
                    <b>Type</b>: {entity.acronym}<br>
                    <b>Position</b>: ({entity.x}, {entity.y})<br>
                    <b>Capacité restante</b>: {entity.storage}<br>
                </p>
                """

    template += """
        </details>
    </body>
    </html>
    """

    filename = "full_snapshot.html"
    with open(filename, "w", encoding="utf-8") as file:
        file.write(template)
    webbrowser.open(f'file:///{os.path.abspath(filename)}')


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Models\Map.py
import math
import random
import os
import pickle
import time
import shutil
from collections import Counter
from datetime import datetime
from Entity.Building import *
from Entity.Unit import *
from Entity.Resource.Resource import *
from Entity.Resource.Gold import Gold
from Entity.Resource.Tree import Tree
from Settings.setup import TILE_SIZE, MAP_WIDTH, MAP_HEIGHT, NUM_GOLD_TILES, NUM_WOOD_TILES, NUM_FOOD_TILES, GOLD_SPAWN_MIDDLE, SAVE_DIRECTORY
from Controller.terminal_display_debug import debug_print

class GameMap:
    def __init__(self, grid_size, center_gold_flag, players, generate=True):
        self.grid_size = grid_size
        self.center_gold_flag = center_gold_flag
        self.players = players
        self.num_tiles_x = grid_size
        self.num_tiles_y = grid_size
        self.num_tiles = self.num_tiles_x * self.num_tiles_y
        self.grid = {}
        self.inactive_matrix = {}
        self.game_state = None  

        # On conserve ces deux variables pour le scroll curses :
        self.terminal_view_x = 0
        self.terminal_view_y = 0

        if generate:
            self.generate_map()

    def add_entity(self, entity, x, y):
        rounded_x, rounded_y = round(x), round(y)
        if (rounded_x < 0 or rounded_y < 0
            or rounded_x + entity.size - 1 >= self.num_tiles_x
            or rounded_y + entity.size - 1 >= self.num_tiles_y):
            return False
        for i in range(entity.size):
            for j in range(entity.size):
                pos = (rounded_x + i, rounded_y + j)
                if pos in self.grid:
                    for existing_entity in self.grid[pos]:
                        if not self.walkable_position(pos):
                            return False

        for i in range(entity.size):
            for j in range(entity.size):
                pos = (rounded_x + i, rounded_y + j)
                if pos not in self.grid:
                    self.grid[pos] = set()
                self.grid[pos].add(entity)

        entity.x = x + (entity.size - 1) / 2
        entity.y = y + (entity.size - 1) / 2
        if entity.team != None:
            self.players[entity.team].add_member(entity)
        return True

    def remove_entity(self, entity):
        remove_counter = 0
        for pos, matrix_entities in list(self.grid.items()):
            for matrix_entity in list(matrix_entities):
                if matrix_entity.entity_id == entity.entity_id:
                    matrix_entities.remove(matrix_entity)
                    remove_counter += 1
                    if not matrix_entities:
                        del self.grid[pos]
                    if remove_counter >= entity.size * entity.size:
                        if entity.team != None:
                            self.players[entity.team].remove_member(entity)
                        return pos
        return False

    def walkable_position(self, position):
        x, y = round(position[0]), round(position[1])
        if x < 0 or y < 0 or x >= self.num_tiles_x or y >= self.num_tiles_y:
            return False
        
        entities = self.grid.get((x, y), None)
        if entities:
            for entity in entities:
                if not entity.walkable:
                    return False
        return True

    def generate_zones(self, num_players):
        cols = int(math.ceil(math.sqrt(num_players)))
        rows = int(math.ceil(num_players / cols))
        zone_width = self.num_tiles_x // cols
        zone_height = self.num_tiles_y // rows
        zones = []
        for i in range(num_players):
            row = i // cols
            col = i % cols
            x_start = col * zone_width
            y_start = row * zone_height
            x_end = x_start + zone_width
            y_end = y_start + zone_height
            zones.append((x_start, x_end, y_start, y_end))
        return zones

    def generate_buildings(self, grid, players):
        num_players = len(players)
        zones = self.generate_zones(num_players)
        for index, player in enumerate(players):
            x_start, x_end, y_start, y_end = zones[player.teamID]
            for building in player.buildings:
                max_attempts = (x_end - x_start) * (y_end - y_start)
                attempts = 0
                placed = False
                while attempts < max_attempts:
                    x = random.randint(x_start, max(x_start, x_end - building.size))
                    y = random.randint(y_start, max(y_start, y_end - building.size))
                    placed = self.add_entity(building, x, y)
                    if placed:
                        break
                    attempts += 1
                if not placed:
                    # fallback
                    for tile_y in range(self.num_tiles_y - building.size):
                        for tile_x in range(self.num_tiles_x - building.size):
                            placed = self.add_entity(building, tile_x, tile_y)
                            if placed:
                                if isinstance(building, (TownCentre, House)):
                                    player.maximum_population += building.population
                                break
                        if placed:
                            break
                    if not placed:
                        raise ValueError("Unable to deploy building (map too crowded?)")

    def generate_units(self, grid, players):
        num_players = len(players)
        zones = self.generate_zones(num_players)
        for index, player in enumerate(players):
            x_start, x_end, y_start, y_end = zones[index]
            for unit in player.units:
                placed = False
                attempts = 0
                while not placed and attempts < 1000:
                    x_unit = random.randint(x_start, x_end - 1)
                    y_unit = random.randint(y_start, y_end - 1)
                    placed = self.add_entity(unit, x_unit, y_unit)
                    attempts += 1
                if not placed:
                    attempts = 0
                    while not placed and attempts < 1000:
                        x_unit = random.randint(0, self.num_tiles_x - 1)
                        y_unit = random.randint(0, self.num_tiles_y - 1)
                        placed = self.add_entity(unit, x_unit, y_unit)
                        attempts += 1
                    if not placed:
                        debug_print(f"Warning: Failed to deploy unit for player {player.teamID} after multiple attempts.")

    def place_gold_near_town_centers(self, grid):
        town_centers = [pos for pos, entities in grid.items() if any(isinstance(e, TownCentre) for e in entities)]
        for center in town_centers:
            x, y = center
            placed = False
            attempts = 0
            while not placed and attempts < 100:
                dx = random.choice([-2, -1, 0, 1])
                dy = random.choice([-2, -1, 0, 1])
                if self.can_place_group(grid, x + dx, y + dy):
                    for i in range(2):
                        for j in range(2):
                            gold = Gold(x + dx + i, y + dy + j)
                            self.add_entity(gold, x + dx + i, y + dy + j)
                    placed = True
                attempts += 1

    def can_place_group(self, grid, x, y):
        if x + 1 < self.num_tiles_x and y + 1 < self.num_tiles_y:
            return all((x + dx, y + dy) not in grid for dx in range(2) for dy in range(2))
        return False
    
    def generate_map(self):
        self.generate_resources()
        self.place_gold_near_town_centers(self.grid)
        self.generate_buildings(self.grid, self.players)
        self.generate_units(self.grid, self.players)
        return self.grid

    def generate_resources(self):
        resource_classes = {'gold': Gold, 'wood': Tree}
        if self.center_gold_flag:
            center_x = self.num_tiles_x // 2
            center_y = self.num_tiles_y // 2
            gold_count = 0
            layer = 0
            max_layer = max(self.num_tiles_x, self.num_tiles_y)
            while gold_count < NUM_GOLD_TILES and layer < max_layer:
                for dx in range(-layer, layer + 1):
                    for dy in range(-layer, layer + 1):
                        x = center_x + dx
                        y = center_y + dy
                        if 0 <= x < self.num_tiles_x and 0 <= y < self.num_tiles_y and (x, y) not in self.grid:
                            self.grid[(x, y)] = set()
                            self.grid[(x, y)].add(resource_classes['gold'](x, y))
                            gold_count += 1
                            if gold_count >= NUM_GOLD_TILES:
                                break
                    if gold_count >= NUM_GOLD_TILES:
                        break
                layer += 1
        else:
            gold_placed = 0
            while gold_placed < NUM_GOLD_TILES:
                x_start = random.randint(0, self.num_tiles_x - 2)
                y_start = random.randint(0, self.num_tiles_y - 2)
                for i in range(2):
                    for j in range(2):
                        if gold_placed >= NUM_GOLD_TILES:
                            break
                        x = x_start + i
                        y = y_start + j
                        attempts = 0
                        placed = False
                        while not placed and attempts < 10:
                            resource = resource_classes['gold'](x, y)
                            placed = self.add_entity(resource, x, y)
                            attempts += 1
                        if placed:
                            gold_placed += 1
                    if gold_placed >= NUM_GOLD_TILES:
                        break

        cluster_size_min, cluster_size_max = 2, 4
        wood_placed = 0
        while wood_placed < NUM_WOOD_TILES:
            cluster_size = random.randint(cluster_size_min, cluster_size_max)
            x_start = random.randint(0, self.num_tiles_x - cluster_size)
            y_start = random.randint(0, self.num_tiles_y - cluster_size)
            for i in range(cluster_size):
                for j in range(cluster_size):
                    if wood_placed >= NUM_WOOD_TILES:
                        break
                    x = x_start + i
                    y = y_start + j
                    attempts = 0
                    placed = False
                    while not placed and attempts < 10:
                        resource = resource_classes['wood'](x, y)
                        placed = self.add_entity(resource, x, y)
                        attempts += 1
                    if placed:
                        wood_placed += 1
                if wood_placed >= NUM_WOOD_TILES:
                    break

    def debug_print_map(self):
        """
        Affichage complet (debug)
        """
        for y in range(self.num_tiles_y):
            row_display = []
            for x in range(self.num_tiles_x):
                pos = (x, y)
                if pos in self.grid:
                    entities = self.grid[pos]
                    acr = list(entities)[0].acronym if entities else ' '
                    row_display.append(acr)
                else:
                    row_display.append(' ')
            debug_print(''.join(row_display))
    
    def save_map(self, filename=None):
        if filename is None:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"save_{timestamp}.pkl"
        else:
            if not filename.endswith('.pkl'):
                filename += '.pkl'
        full_path = os.path.join(SAVE_DIRECTORY, filename)
        data = {
            'grid': self.grid,
            'grid_size': self.grid_size,
            'center_gold_flag': self.center_gold_flag,
            'players': self.players
        }
        with open(full_path, 'wb') as f:
            pickle.dump(data, f)
        debug_print(f"Game map saved successfully to {full_path}.")

    def load_map(self, filename):
        try:
            with open(filename, 'rb') as f:
                data = pickle.load(f)
            self.grid = data['grid']
            self.grid_size = data['grid_size']
            self.center_gold_flag = data['center_gold_flag']
            self.players = data['players']
            self.num_tiles_x = self.num_tiles_y = self.grid_size
            debug_print(f"Game map loaded successfully from {filename}.")
        except Exception as e:
            debug_print(f"Error loading game map: {e}")



    def move_to_inactive(self, entity):
        self.remove_entity(entity)
        pos = (round(entity.x), round(entity.y))
        if pos not in self.inactive_matrix:
            self.inactive_matrix[pos] = set()
        self.inactive_matrix[pos].add(entity)

    def remove_inactive(self, entity):
        pos = (round(entity.x), round(entity.y))
        self.inactive_matrix[pos].remove(entity)
        if not self.inactive_matrix[pos]:
            del self.inactive_matrix[pos]

    def patch(self, dt):
        for entities in list(self.grid.values()):
            if entities:
                for entity in list(entities):
                    entity.update(self, dt)
                    if not entity.isAlive():
                        self.move_to_inactive(entity)

        for inactive_entities in list(self.inactive_matrix.values()):
            if inactive_entities:
                for entity in list(inactive_entities):
                    entity.update(self, dt)
                    if not entity.state:
                        self.remove_inactive(entity)

    def set_game_state(self, game_state):
        self.game_state = game_state


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Models\Resources.py
from Controller.terminal_display_debug import debug_print

class Resources:
    def __init__(self, food=0, gold=0, wood=0):
        self.food = food
        self.gold = gold
        self.wood = wood

    def reset(self):
        self.food = 0
        self.gold = 0
        self.wood = 0
        
    def set_resources(self, food=0, gold=0, wood=0):
        self.food = food
        self.gold = gold
        self.wood = wood


    def add_food(self, amount):
        self.food += amount
        return amount

    def remove_food(self, amount):
        removed = min(self.food, amount)
        self.food -= removed
        return removed

    def add_gold(self, amount):
        self.gold += amount
        return amount

    def remove_gold(self, amount):
        removed = min(self.gold, amount)
        self.gold -= removed
        return removed

    def add_wood(self, amount):
        self.wood += amount
        return amount

    def remove_wood(self, amount):
        removed = min(self.wood, amount)
        self.wood -= removed
        return removed

    def increase_resources(self, resources):
        food, gold, wood = resources
        self.food += food
        self.gold += gold
        self.wood += wood
        return (food, gold, wood)

    def decrease_resources(self, resources):
        food, gold, wood = resources
        removed_food = min(self.food, food)
        removed_gold = min(self.gold, gold)
        removed_wood = min(self.wood, wood)
        self.food -= removed_food
        self.gold -= removed_gold
        self.wood -= removed_wood
        return (removed_food, removed_gold, removed_wood)

    def has_enough(self, costs):
        return all(resource >= cost for resource, cost in zip(self.get(), costs))

    def get(self):
        return (self.food, self.gold, self.wood)

    def total(self):
        return self.food + self.gold + self.wood

    def copy(self):
        return Resources(self.food, self.gold, self.wood)

    def __eq__(self, other):
        if isinstance(other, Resources):
            return self.food == other.food and self.gold == other.gold and self.wood == other.wood
        return False

    def __repr__(self):
        return f"Resources(food={self.food}, wood={self.wood}, gold={self.gold})"


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Models\Team.py
from collections import Counter
from Settings.setup import *
from Settings.entity_mapping import *
from Entity.Entity import *
from Entity.Building import *
from Entity.Unit import *
from Entity.Resource import Resource
from Models.Map import GameMap
from Controller.terminal_display_debug import debug_print

class Team:
    def __init__(self, difficulty, teamID):
        self.resources = difficulty_config[difficulty]['Resources'].copy()

        self.units = set()
        self.buildings = set()
        self.teamID = teamID

        self.population = 0
        self.maximum_population = 0
        self.en_cours = {}

        for building, amount in difficulty_config[difficulty]['Buildings'].items():
            for _ in range(amount):
                if building in building_class_map:
                    self.add_member(building_class_map[building](team=teamID))

        for unit, amount in difficulty_config[difficulty]['Units'].items():
            for _ in range(amount):
                if unit in unit_class_map:
                    self.add_member(unit_class_map[unit](team=teamID))

    def add_member(self, entity):
        if entity.team == self.teamID :
            if entity in self.buildings or entity in self.units:
                return False

            if isinstance(entity, Building):
                if entity.population + self.maximum_population > MAXIMUM_POPULATION :
                    debug_print("Maximum population reached")
                    return False

                self.buildings.add(entity)
                self.maximum_population += entity.population
                debug_print(f'addded {entity} : {entity.entity_id} to team #{entity.team}')
                return True

            elif isinstance(entity, Unit):
                if self.population + 1 > self.maximum_population:
                    debug_print("Failed to add entity : Not enough space")
                    return False

                self.units.add(entity)
                self.population += 1
                return True
        return False

    def remove_member(self, entity):
        if entity.team == self.teamID:
            if isinstance(entity, Building):
                if entity in self.buildings:
                    self.buildings.remove(entity)
                    self.maximum_population -= entity.population
                    return True
            elif isinstance(entity, Unit):
                if entity in self.units:
                    self.units.remove(entity)
                    self.population -= 1
                    return True
        return False

    def modify_resources(self, Resources):
        """
        Modifie directement les ressources de l'équipe (ex: +100 gold, -50 wood, etc.).
        Note : appelle un refresh GUI.
        """
        self.resources['food'] += Resources.food 
        self.resources['wood'] += Resources.wood 
        self.resources['gold'] += Resources.gold
    
    def manage_creation(self, clock):
        """
        Gère la création de bâtiments/unités (self.en_cours).
        Une fois le temps écoulé => on les place dans .units ou .buildings.
        """
        to_remove = []
        for entity, start_time in self.en_cours.items():
            if isinstance(entity, Building):
                if start_time - clock <= 0:
                    self.buildings.append(entity)
                    for villager in entity.constructors:
                        villager.task=False
                    if isinstance(entity,House) or isinstance(entity,TownCentre):
                        self.maximum_population+=5
                    to_remove.append(entity)
                    for villager in entity.constructors:
                        villager.task = False
            else:
                if entity.training_time + start_time - clock <= 0:
                    to_remove.append(entity)
                    self.units.append(entity)

        for entity in to_remove:
            del self.en_cours[entity]

    def buildBuilding(self, building, clock, nb, game_map):
        if all([v.task for v in self.units if isinstance(v, Villager)]):
            debug_print("All villagers are busy.")
            return False

        if self.resources["wood"] >= building.cost.wood:
            self.resources["wood"] -= building.cost.wood
        else:
            debug_print(f"Team {self.teamID}: Not enough wood.")
            return False
        if not game_map.place_building(building,self):
            debug_print("cannot place")
            return False
       
        i=0
        num_constructors=0
        while(i<len(self.units) and num_constructors<nb):
            unit=self.units[i]
            if isinstance(unit,Villager) and not(unit.task):
                unit.build(map,building)
                num_constructors +=1
                v1=v
            i+=1
         
        self.en_cours[building]=clock+v1.buildTime(building,num_constructors) 

        i = 0
        j = 0
        chosen_villager = None
        while i < len(self.units) and j < nb:
            v = self.units[i]
            if isinstance(v, Villager) and not v.task:
                v.build(game_map, building)
                j += 1
                chosen_villager = v
            i += 1

        if chosen_villager:
            total_build_time = chosen_villager.buildTime(building, j)
            self.en_cours[building] = clock + total_build_time
        else:
            debug_print("No free villager found to build.")
            return False

        self.buildings.append(building)
        if hasattr(building, 'population'): #rajouter condition pour pas depasser MAXIMUM_POPULATION a 200
            self.maximum_population += building.population
        game_map.game_state['player_info_updated'] = True

        return True

    def battle(self,t,map,nb):
        """
        Attaque t, et l'adversaire défend.
        """
        for i in range(0,len(t.units)):
            soldier=t.units[i]
            if not(soldier.task) and not(isinstance(soldier,Villager)):
                debug_print("ok")
                soldier.task=True
                soldier.attack(self,map)
    
        for i in range(0,min(nb,len(self.units))):
            soldier=self.units[i]
            if not(soldier.task) and not(isinstance(soldier,Villager)):
               
                soldier.task=True
                soldier.attack(t,map)

    def battle_v2(self,t,map,nb):
        """
        Attaque t, et l'adversaire ne défend pas.
        """
        i=0
        nb_soldier=0
        while(i<len(self.units) and nb_soldier< nb):
            soldier=self.units[i]
            if not(soldier.task) and not(isinstance(soldier,Villager)):
                nb_soldier+=1
                soldier.task=True
                if soldier.target:
                    soldier.attack(t,map)
            i+=1

    def modify_target(self,target,players_target):
        """
        Met à jour la cible de l'équipe (arrête toutes les attaques de la team)
        pour la remplacer par la nouvelle 'target'.
        """
        players_target[self.teamID]=target
        for unit in self.units:
            if not isinstance(unit,Villager):
                unit.target=None
                unit.task=True
                if unit.target:
                    unit.attack(target,map)

    def collectResource(self, villager, resource_tile, duration, game_map):
        """
        Méthode de récolte de ressources : villager se déplace et récolte sur 'resource_tile'.
        La quantité récoltée dépend de 'duration' et du 'resource_rate' du villager.
        """
        if not isinstance(villager, Villager):
            return
        if not villager.isAvailable():
            return
        villager.task = True
        villager.move(resource_tile.x, resource_tile.y, game_map)

        collected = min(
            villager.resource_rate * duration,
            villager.carry_capacity - getattr(villager.resources, resource_tile.acronym.lower(), 0)
        )
        setattr(
            villager.resources,
            resource_tile.acronym.lower(),
            getattr(villager.resources, resource_tile.acronym.lower(), 0) + collected
        )
        
        resource_tile.storage = Resources(
            food=resource_tile.storage.food - (collected if resource_tile.acronym == "F" else 0),
            gold=resource_tile.storage.gold - (collected if resource_tile.acronym == "G" else 0),
            wood=resource_tile.storage.wood - (collected if resource_tile.acronym == "W" else 0),
        )
        
        if (resource_tile.storage.food <= 0 
            and resource_tile.storage.gold <= 0 
            and resource_tile.storage.wood <= 0):
            game_map.remove_entity(resource_tile, resource_tile.x, resource_tile.y)

        villager.task = False
        # ----------- AJOUT POUR METTRE A JOUR L'AFFICHAGE -----------
        game_map.game_state['player_info_updated'] = True
        # ------------------------------------------------------------

    def stockResources(self, villager, building, game_map):
        """
        Le villager va déposer ses ressources dans 'building' s'il le peut.
        """
        if not isinstance(villager, Villager):
            return
        if not villager.isAvailable() or not hasattr(building, 'resourceDropPoint') or not building.resourceDropPoint:
            return
        villager.task = True
        villager.move(building.x, building.y, game_map)
        self.resources = Resources(
            food=self.resources["food"] + villager.resources.food,
            gold=self.resources["gold"] + villager.resources.gold,
            wood=self.resources["wood"] + villager.resources.wood,
        )
        villager.resources = Resources(food=0, gold=0, wood=0)
        villager.task = False
        # On refresh l'UI
        game_map.game_state['player_info_updated'] = True


--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Settings\entity_mapping.py
from Entity.Unit import *
from Entity.Building import *
from Entity.Resource import *
# -------------------
# Mapping Entity Classess
# -------------------
unit_class_map = {
        'Villager': Villager,
        'Archer': Archer,
        'Horseman': Horseman,
        'Swordsman': Swordsman
    }

building_class_map = {
        'TownCenter': TownCentre,
        'Barracks': Barracks,
        'Stable': Stable,
        'ArcheryRange': ArcheryRange,
        'Farm': Farm,
        'Keep': Keep,
        'House': House,
        'Camp': Camp
    }

resources_class_map = {
        'Gold': Gold,
        'Tree': Tree
    }

--------

# Chemin de C:/Users/cyril/OneDrive/Documents/INSA/3A/Projet_python\Settings\setup.py
from collections import namedtuple
from Models.Resources import Resources
import os

# -------------------
# Global Constants
# Classe Villager
# -------------------
GAME_SPEED = 10
FPS_DRAW_LIMITER = 50
BUILDING_TIME_REDUCTION = 0.75
RESOURCE_RATE_PER_SEC = 25 / 60
MAXIMUM_CARRY = 20

# -------------------
# Unit constants
# -------------------
ALLOWED_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315]
UPDATE_EVERY_N_MILLISECOND = 20
ONE_SECOND = 1000
FRAMES_PER_UNIT = 10
FRAMES_PER_BUILDING = 15
UNIT_HITBOX = 0.3
ATTACK_RANGE_EPSILON = 0.5

# -------------------
# Config For Teams
# -------------------
MAXIMUM_POPULATION = 200

difficulty_config = {
    'lean' : {
        'Resources' : Resources(food=50, gold=200, wood=50),
        'Units' : {
            'Villager' : 3
        },
        'Buildings' : {
            'TownCenter' : 1
        }

    },

    'mean' : {
        'Resources' : Resources(food=2000, gold=2000, wood=2000),
        'Units' : {
            'Villager' : 3
        },
        'Buildings' : {
            'TownCenter' : 1
        }

    },

    'marines' : {
        'Resources' : Resources(food=20000, gold=20000, wood=20000),
        'Units' : {
            'Villager' : 15
        },
        'Buildings' : {
            'TownCenter' : 3,
            'Barracks' : 2,
            'Stable' : 2, 
            'ArcheryRange' : 2,
        }
    },

    'DEBUG' : {
        'Resources' : Resources(food=99999, gold=99999, wood=99999),
        'Units' : {
            'Villager' : 10,
            'Archer' : 10,
            'Horseman' : 10,
            'Swordsman' : 10
        },
        'Buildings' : {
            'TownCenter' : 5,
            'Barracks' : 1,
            'Stable' : 1, 
            'ArcheryRange' : 1,
            'Farm' : 1,
            'Keep' : 1,
            'House' : 5,
            'Camp' : 2,
        }
    }
}

# -------------------
# Map Configuration
# -------------------
TILE_SIZE = 200
HALF_TILE_SIZE = TILE_SIZE / 2
MAP_WIDTH = 120 * TILE_SIZE
MAP_HEIGHT = 120 * TILE_SIZE
MIN_ZOOM = 0.15
MAX_ZOOM = 3.0
WINDOW_WIDTH = 1200
WINDOW_HEIGHT = 1200
NUM_GOLD_TILES = 500
NUM_WOOD_TILES = 500
NUM_FOOD_TILES = 500
GOLD_SPAWN_MIDDLE = False
MAP_PADDING = 650

# -------------------
# Minimap Settings
# -------------------
MINIMAP_WIDTH = 600
MINIMAP_HEIGHT = 280
MINIMAP_MARGIN = 20
PANEL_RATIO = 0.25
BG_RATIO    = 0.20

# -------------------
# Save Directory
# -------------------
SAVE_DIRECTORY = 'saves'
if not os.path.exists(SAVE_DIRECTORY):
    os.makedirs(SAVE_DIRECTORY)

# -------------------
# Sprites Configuration
# -------------------
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

gui_config = {
    'loading_screen': {
        'directory': 'assets/launcher/',
        'scale': None
    },

    'ResourcesPanel' :{
        'directory' : 'assets/UI/Panels/resourcesPan', 
    }, 

    'minimapPanel' :{
        'directory' : 'assets/UI/Panels/minimapPan', 
    },

    'gold':{
        'directory' : 'assets/UI/Resources/gold',
    },

    'wood':{
        'directory' : 'assets/UI/Resources/wood',
    },

    'food':{
        'directory' : 'assets/UI/Resources/food',
    },

    'pointer':{
        'directory' : 'assets/UI/Pointer/',
    },

}

BAR_HEIGHT = 30
BAR_BORDER_RADIUS = 30
PROGRESS_BAR_WIDTH_RATIO = 0.8
PROGRESS_BAR_Y_RATIO = 0.9

BUILDING_RATIO = 100
UNIT_RATIO = 100

HEALTH_BAR_WIDTH = 40
HEALTH_BAR_HEIGHT = 5
HEALTH_BAR_OFFSET_Y = 30

Entity_Acronym = {
    'resources': {
        ' ': 'grass',
        'W': 'tree',
        'G': 'gold',
        'F': 'food'
    },
    'buildings': {
        'A': 'archeryrange',
        'B': 'barracks',
        'C': 'camp',
        'F': 'farm',
        'H': 'house',
        'K': 'keep',
        'S': 'stable',
        'T': 'towncenter'
    },
    'units': {
        'a': 'archer',
        'h': 'horseman',
        's': 'swordsman',
        'v': 'villager'
    }
}

states = {
     0: 'idle',
     1: 'walk',
     2: 'attack',
     3: 'death',
     4: 'decay',
     5: 'task',
     7: 'inactive'
}

villager_tasks = {
        "attack": "attack_target",
        "collect": "collect_target",
        "build": "build_target",
        "stock": "stock_target"
    }

sprite_config = {
    'buildings': {
        'towncenter': {
            'directory': 'assets/buildings/towncenter/',
            'states': 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'barracks': {
            'directory': 'assets/buildings/barracks/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'stable': {
            'directory': 'assets/buildings/stable/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'archeryrange': {
            'directory': 'assets/buildings/archeryrange/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'keep': {
            'directory': 'assets/buildings/keep/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'camp': {
            'directory': 'assets/buildings/camp/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'house': {
            'directory': 'assets/buildings/house/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / BUILDING_RATIO,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
        'farm': {
            'directory': 'assets/buildings/farm/',
            'states' : 2,
            'adjust_scale': TILE_SIZE / 120,
            'sheet_config': {
                'columns': 10,
                'rows': 10
            },
        },
    },
    'resources': {
        'grass': {
            'directory': 'assets/resources/grass/',
            'scale': (10 * TILE_SIZE // 2, 10 * TILE_SIZE // 4)
        },
        'gold': {
            'directory': 'assets/resources/gold/',
            'scale': (TILE_SIZE, TILE_SIZE),
            'variant': 6
        },
        'tree': {
            'directory': 'assets/resources/tree/',
            'scale': (TILE_SIZE, TILE_SIZE),
            'variant': 4
        }
    },
    'units': {
        'swordsman': {
            'directory': 'assets/units/swordsman/',
            'states': 5,
            'adjust_scale': TILE_SIZE / UNIT_RATIO,
            'sheet_config': {
                'columns': 30,
                'rows': 16
            },
        },
        'villager': {
            'directory': 'assets/units/villager/',
            'states': 6,
            'adjust_scale': TILE_SIZE / UNIT_RATIO,
            'sheet_config': {
                'columns': 30,
                'rows': 16
            },
        },
        'archer': {
            'directory': 'assets/units/archer/',
            'states': 5,
            'adjust_scale': TILE_SIZE / UNIT_RATIO,
            'sheet_config': {
                'columns': 30,
                'rows': 16
            },
        },
        'horseman': {
            'directory': 'assets/units/horseman/',
            'states': 5,
            'adjust_scale': TILE_SIZE / UNIT_RATIO,
            'sheet_config': {
                'columns': 30,
                'rows': 16
            },
        }
    }
}

# ----
# Menu
# ----

user_choices = {
    "grid_size":      120,
    "num_bots":       2,
    "bot_level":      "lean",
    "gold_at_center": False,
    "load_game":      False,
    "chosen_save":    None,
    "validated":      False,
    "index_terminal_display" : 0 # 0: GUI, 1: Terminal, 2: Both
}

VALID_GRID_SIZES = [i for i in range(100, 1000, 10)]
VALID_BOTS_COUNT = [i for i in range(1, 56)]
VALID_LEVELS = ["lean", "mean", "marines", "DEBUG"]

# Pour la gestion du scroll dans chaque combo
combo_scroll_positions = {
    "grid": 0,
    "nbot": 0,
    "lvl":  0
}
MAX_VISIBLE_ITEMS = 5
ITEM_HEIGHT = 25





--------


